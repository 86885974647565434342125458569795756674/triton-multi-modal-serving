// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model_config.proto

#include "model_config.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace inference {
constexpr ModelRateLimiter_Resource::ModelRateLimiter_Resource(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , global_(false)
  , count_(0u){}
struct ModelRateLimiter_ResourceDefaultTypeInternal {
  constexpr ModelRateLimiter_ResourceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelRateLimiter_ResourceDefaultTypeInternal() {}
  union {
    ModelRateLimiter_Resource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelRateLimiter_ResourceDefaultTypeInternal _ModelRateLimiter_Resource_default_instance_;
constexpr ModelRateLimiter::ModelRateLimiter(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : resources_()
  , priority_(0u){}
struct ModelRateLimiterDefaultTypeInternal {
  constexpr ModelRateLimiterDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelRateLimiterDefaultTypeInternal() {}
  union {
    ModelRateLimiter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelRateLimiterDefaultTypeInternal _ModelRateLimiter_default_instance_;
constexpr ModelInstanceGroup_SecondaryDevice::ModelInstanceGroup_SecondaryDevice(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : device_id_(int64_t{0})
  , kind_(0)
{}
struct ModelInstanceGroup_SecondaryDeviceDefaultTypeInternal {
  constexpr ModelInstanceGroup_SecondaryDeviceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelInstanceGroup_SecondaryDeviceDefaultTypeInternal() {}
  union {
    ModelInstanceGroup_SecondaryDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelInstanceGroup_SecondaryDeviceDefaultTypeInternal _ModelInstanceGroup_SecondaryDevice_default_instance_;
constexpr ModelInstanceGroup::ModelInstanceGroup(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gpus_()
  , _gpus_cached_byte_size_(0)
  , profile_()
  , secondary_devices_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , host_policy_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , rate_limiter_(nullptr)
  , count_(0)
  , kind_(0)

  , passive_(false){}
struct ModelInstanceGroupDefaultTypeInternal {
  constexpr ModelInstanceGroupDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelInstanceGroupDefaultTypeInternal() {}
  union {
    ModelInstanceGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelInstanceGroupDefaultTypeInternal _ModelInstanceGroup_default_instance_;
constexpr ModelTensorReshape::ModelTensorReshape(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : shape_()
  , _shape_cached_byte_size_(0){}
struct ModelTensorReshapeDefaultTypeInternal {
  constexpr ModelTensorReshapeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelTensorReshapeDefaultTypeInternal() {}
  union {
    ModelTensorReshape _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelTensorReshapeDefaultTypeInternal _ModelTensorReshape_default_instance_;
constexpr ModelInput::ModelInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dims_()
  , _dims_cached_byte_size_(0)
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , reshape_(nullptr)
  , data_type_(0)

  , format_(0)

  , is_shape_tensor_(false)
  , allow_ragged_batch_(false)
  , optional_(false){}
struct ModelInputDefaultTypeInternal {
  constexpr ModelInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelInputDefaultTypeInternal() {}
  union {
    ModelInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelInputDefaultTypeInternal _ModelInput_default_instance_;
constexpr ModelOutput::ModelOutput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dims_()
  , _dims_cached_byte_size_(0)
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , label_filename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , reshape_(nullptr)
  , data_type_(0)

  , is_shape_tensor_(false){}
struct ModelOutputDefaultTypeInternal {
  constexpr ModelOutputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOutputDefaultTypeInternal() {}
  union {
    ModelOutput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOutputDefaultTypeInternal _ModelOutput_default_instance_;
constexpr BatchInput::BatchInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : target_name_()
  , source_input_()
  , kind_(0)

  , data_type_(0)
{}
struct BatchInputDefaultTypeInternal {
  constexpr BatchInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BatchInputDefaultTypeInternal() {}
  union {
    BatchInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BatchInputDefaultTypeInternal _BatchInput_default_instance_;
constexpr BatchOutput::BatchOutput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : target_name_()
  , source_input_()
  , kind_(0)
{}
struct BatchOutputDefaultTypeInternal {
  constexpr BatchOutputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BatchOutputDefaultTypeInternal() {}
  union {
    BatchOutput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BatchOutputDefaultTypeInternal _BatchOutput_default_instance_;
constexpr ModelVersionPolicy_Latest::ModelVersionPolicy_Latest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : num_versions_(0u){}
struct ModelVersionPolicy_LatestDefaultTypeInternal {
  constexpr ModelVersionPolicy_LatestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelVersionPolicy_LatestDefaultTypeInternal() {}
  union {
    ModelVersionPolicy_Latest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelVersionPolicy_LatestDefaultTypeInternal _ModelVersionPolicy_Latest_default_instance_;
constexpr ModelVersionPolicy_All::ModelVersionPolicy_All(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelVersionPolicy_AllDefaultTypeInternal {
  constexpr ModelVersionPolicy_AllDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelVersionPolicy_AllDefaultTypeInternal() {}
  union {
    ModelVersionPolicy_All _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelVersionPolicy_AllDefaultTypeInternal _ModelVersionPolicy_All_default_instance_;
constexpr ModelVersionPolicy_Specific::ModelVersionPolicy_Specific(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : versions_()
  , _versions_cached_byte_size_(0){}
struct ModelVersionPolicy_SpecificDefaultTypeInternal {
  constexpr ModelVersionPolicy_SpecificDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelVersionPolicy_SpecificDefaultTypeInternal() {}
  union {
    ModelVersionPolicy_Specific _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelVersionPolicy_SpecificDefaultTypeInternal _ModelVersionPolicy_Specific_default_instance_;
constexpr ModelVersionPolicy::ModelVersionPolicy(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct ModelVersionPolicyDefaultTypeInternal {
  constexpr ModelVersionPolicyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelVersionPolicyDefaultTypeInternal() {}
  union {
    ModelVersionPolicy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelVersionPolicyDefaultTypeInternal _ModelVersionPolicy_default_instance_;
constexpr ModelOptimizationPolicy_Graph::ModelOptimizationPolicy_Graph(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : level_(0){}
struct ModelOptimizationPolicy_GraphDefaultTypeInternal {
  constexpr ModelOptimizationPolicy_GraphDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_GraphDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Graph _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOptimizationPolicy_GraphDefaultTypeInternal _ModelOptimizationPolicy_Graph_default_instance_;
constexpr ModelOptimizationPolicy_Cuda_GraphSpec_Shape::ModelOptimizationPolicy_Cuda_GraphSpec_Shape(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dim_()
  , _dim_cached_byte_size_(0){}
struct ModelOptimizationPolicy_Cuda_GraphSpec_ShapeDefaultTypeInternal {
  constexpr ModelOptimizationPolicy_Cuda_GraphSpec_ShapeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpec_ShapeDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Cuda_GraphSpec_Shape _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOptimizationPolicy_Cuda_GraphSpec_ShapeDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_Shape_default_instance_;
constexpr ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUseDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse_default_instance_;
constexpr ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , batch_size_(0){}
struct ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundDefaultTypeInternal {
  constexpr ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_default_instance_;
constexpr ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUseDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse_default_instance_;
constexpr ModelOptimizationPolicy_Cuda_GraphSpec::ModelOptimizationPolicy_Cuda_GraphSpec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , graph_lower_bound_(nullptr)
  , batch_size_(0){}
struct ModelOptimizationPolicy_Cuda_GraphSpecDefaultTypeInternal {
  constexpr ModelOptimizationPolicy_Cuda_GraphSpecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_Cuda_GraphSpecDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Cuda_GraphSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOptimizationPolicy_Cuda_GraphSpecDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_default_instance_;
constexpr ModelOptimizationPolicy_Cuda::ModelOptimizationPolicy_Cuda(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : graph_spec_()
  , graphs_(false)
  , busy_wait_events_(false)
  , output_copy_stream_(false){}
struct ModelOptimizationPolicy_CudaDefaultTypeInternal {
  constexpr ModelOptimizationPolicy_CudaDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_CudaDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_Cuda _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOptimizationPolicy_CudaDefaultTypeInternal _ModelOptimizationPolicy_Cuda_default_instance_;
constexpr ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUseDefaultTypeInternal _ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse_default_instance_;
constexpr ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : parameters_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorDefaultTypeInternal {
  constexpr ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_ExecutionAccelerators_Accelerator _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorDefaultTypeInternal _ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_default_instance_;
constexpr ModelOptimizationPolicy_ExecutionAccelerators::ModelOptimizationPolicy_ExecutionAccelerators(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gpu_execution_accelerator_()
  , cpu_execution_accelerator_(){}
struct ModelOptimizationPolicy_ExecutionAcceleratorsDefaultTypeInternal {
  constexpr ModelOptimizationPolicy_ExecutionAcceleratorsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_ExecutionAcceleratorsDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_ExecutionAccelerators _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOptimizationPolicy_ExecutionAcceleratorsDefaultTypeInternal _ModelOptimizationPolicy_ExecutionAccelerators_default_instance_;
constexpr ModelOptimizationPolicy_PinnedMemoryBuffer::ModelOptimizationPolicy_PinnedMemoryBuffer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : enable_(false){}
struct ModelOptimizationPolicy_PinnedMemoryBufferDefaultTypeInternal {
  constexpr ModelOptimizationPolicy_PinnedMemoryBufferDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOptimizationPolicy_PinnedMemoryBufferDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy_PinnedMemoryBuffer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOptimizationPolicy_PinnedMemoryBufferDefaultTypeInternal _ModelOptimizationPolicy_PinnedMemoryBuffer_default_instance_;
constexpr ModelOptimizationPolicy::ModelOptimizationPolicy(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : graph_(nullptr)
  , cuda_(nullptr)
  , execution_accelerators_(nullptr)
  , input_pinned_memory_(nullptr)
  , output_pinned_memory_(nullptr)
  , priority_(0)

  , gather_kernel_buffer_threshold_(0u)
  , eager_batching_(false){}
struct ModelOptimizationPolicyDefaultTypeInternal {
  constexpr ModelOptimizationPolicyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOptimizationPolicyDefaultTypeInternal() {}
  union {
    ModelOptimizationPolicy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOptimizationPolicyDefaultTypeInternal _ModelOptimizationPolicy_default_instance_;
constexpr ModelQueuePolicy::ModelQueuePolicy(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : default_timeout_microseconds_(uint64_t{0u})
  , timeout_action_(0)

  , allow_timeout_override_(false)
  , max_queue_size_(0u){}
struct ModelQueuePolicyDefaultTypeInternal {
  constexpr ModelQueuePolicyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelQueuePolicyDefaultTypeInternal() {}
  union {
    ModelQueuePolicy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelQueuePolicyDefaultTypeInternal _ModelQueuePolicy_default_instance_;
constexpr ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUseDefaultTypeInternal _ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse_default_instance_;
constexpr ModelDynamicBatching::ModelDynamicBatching(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : preferred_batch_size_()
  , _preferred_batch_size_cached_byte_size_(0)
  , priority_queue_policy_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , default_queue_policy_(nullptr)
  , max_queue_delay_microseconds_(uint64_t{0u})
  , priority_levels_(uint64_t{0u})
  , default_priority_level_(uint64_t{0u})
  , preserve_ordering_(false){}
struct ModelDynamicBatchingDefaultTypeInternal {
  constexpr ModelDynamicBatchingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelDynamicBatchingDefaultTypeInternal() {}
  union {
    ModelDynamicBatching _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelDynamicBatchingDefaultTypeInternal _ModelDynamicBatching_default_instance_;
constexpr ModelSequenceBatching_Control::ModelSequenceBatching_Control(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : int32_false_true_()
  , _int32_false_true_cached_byte_size_(0)
  , fp32_false_true_()
  , bool_false_true_()
  , kind_(0)

  , data_type_(0)
{}
struct ModelSequenceBatching_ControlDefaultTypeInternal {
  constexpr ModelSequenceBatching_ControlDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelSequenceBatching_ControlDefaultTypeInternal() {}
  union {
    ModelSequenceBatching_Control _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelSequenceBatching_ControlDefaultTypeInternal _ModelSequenceBatching_Control_default_instance_;
constexpr ModelSequenceBatching_ControlInput::ModelSequenceBatching_ControlInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : control_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct ModelSequenceBatching_ControlInputDefaultTypeInternal {
  constexpr ModelSequenceBatching_ControlInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelSequenceBatching_ControlInputDefaultTypeInternal() {}
  union {
    ModelSequenceBatching_ControlInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelSequenceBatching_ControlInputDefaultTypeInternal _ModelSequenceBatching_ControlInput_default_instance_;
constexpr ModelSequenceBatching_InitialState::ModelSequenceBatching_InitialState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dims_()
  , _dims_cached_byte_size_(0)
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , data_type_(0)

  , _oneof_case_{}{}
struct ModelSequenceBatching_InitialStateDefaultTypeInternal {
  constexpr ModelSequenceBatching_InitialStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelSequenceBatching_InitialStateDefaultTypeInternal() {}
  union {
    ModelSequenceBatching_InitialState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelSequenceBatching_InitialStateDefaultTypeInternal _ModelSequenceBatching_InitialState_default_instance_;
constexpr ModelSequenceBatching_State::ModelSequenceBatching_State(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dims_()
  , _dims_cached_byte_size_(0)
  , initial_state_()
  , input_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , output_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , data_type_(0)

  , use_same_buffer_for_input_output_(false)
  , use_growable_memory_(false){}
struct ModelSequenceBatching_StateDefaultTypeInternal {
  constexpr ModelSequenceBatching_StateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelSequenceBatching_StateDefaultTypeInternal() {}
  union {
    ModelSequenceBatching_State _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelSequenceBatching_StateDefaultTypeInternal _ModelSequenceBatching_State_default_instance_;
constexpr ModelSequenceBatching_StrategyDirect::ModelSequenceBatching_StrategyDirect(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : max_queue_delay_microseconds_(uint64_t{0u})
  , minimum_slot_utilization_(0){}
struct ModelSequenceBatching_StrategyDirectDefaultTypeInternal {
  constexpr ModelSequenceBatching_StrategyDirectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelSequenceBatching_StrategyDirectDefaultTypeInternal() {}
  union {
    ModelSequenceBatching_StrategyDirect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelSequenceBatching_StrategyDirectDefaultTypeInternal _ModelSequenceBatching_StrategyDirect_default_instance_;
constexpr ModelSequenceBatching_StrategyOldest::ModelSequenceBatching_StrategyOldest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : preferred_batch_size_()
  , _preferred_batch_size_cached_byte_size_(0)
  , max_candidate_sequences_(0)
  , preserve_ordering_(false)
  , max_queue_delay_microseconds_(uint64_t{0u}){}
struct ModelSequenceBatching_StrategyOldestDefaultTypeInternal {
  constexpr ModelSequenceBatching_StrategyOldestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelSequenceBatching_StrategyOldestDefaultTypeInternal() {}
  union {
    ModelSequenceBatching_StrategyOldest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelSequenceBatching_StrategyOldestDefaultTypeInternal _ModelSequenceBatching_StrategyOldest_default_instance_;
constexpr ModelSequenceBatching::ModelSequenceBatching(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : control_input_()
  , state_()
  , max_sequence_idle_microseconds_(uint64_t{0u})
  , iterative_sequence_(false)
  , _oneof_case_{}{}
struct ModelSequenceBatchingDefaultTypeInternal {
  constexpr ModelSequenceBatchingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelSequenceBatchingDefaultTypeInternal() {}
  union {
    ModelSequenceBatching _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelSequenceBatchingDefaultTypeInternal _ModelSequenceBatching_default_instance_;
constexpr ModelEnsembling_Step_InputMapEntry_DoNotUse::ModelEnsembling_Step_InputMapEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelEnsembling_Step_InputMapEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelEnsembling_Step_InputMapEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelEnsembling_Step_InputMapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelEnsembling_Step_InputMapEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelEnsembling_Step_InputMapEntry_DoNotUseDefaultTypeInternal _ModelEnsembling_Step_InputMapEntry_DoNotUse_default_instance_;
constexpr ModelEnsembling_Step_OutputMapEntry_DoNotUse::ModelEnsembling_Step_OutputMapEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelEnsembling_Step_OutputMapEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelEnsembling_Step_OutputMapEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelEnsembling_Step_OutputMapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelEnsembling_Step_OutputMapEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelEnsembling_Step_OutputMapEntry_DoNotUseDefaultTypeInternal _ModelEnsembling_Step_OutputMapEntry_DoNotUse_default_instance_;
constexpr ModelEnsembling_Step::ModelEnsembling_Step(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_map_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , output_map_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , model_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , model_namespace_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , model_version_(int64_t{0}){}
struct ModelEnsembling_StepDefaultTypeInternal {
  constexpr ModelEnsembling_StepDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelEnsembling_StepDefaultTypeInternal() {}
  union {
    ModelEnsembling_Step _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelEnsembling_StepDefaultTypeInternal _ModelEnsembling_Step_default_instance_;
constexpr ModelEnsembling::ModelEnsembling(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : step_(){}
struct ModelEnsemblingDefaultTypeInternal {
  constexpr ModelEnsemblingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelEnsemblingDefaultTypeInternal() {}
  union {
    ModelEnsembling _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelEnsemblingDefaultTypeInternal _ModelEnsembling_default_instance_;
constexpr ModelParameter::ModelParameter(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : string_value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct ModelParameterDefaultTypeInternal {
  constexpr ModelParameterDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelParameterDefaultTypeInternal() {}
  union {
    ModelParameter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelParameterDefaultTypeInternal _ModelParameter_default_instance_;
constexpr ModelWarmup_Input::ModelWarmup_Input(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dims_()
  , _dims_cached_byte_size_(0)
  , data_type_(0)

  , _oneof_case_{}{}
struct ModelWarmup_InputDefaultTypeInternal {
  constexpr ModelWarmup_InputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelWarmup_InputDefaultTypeInternal() {}
  union {
    ModelWarmup_Input _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelWarmup_InputDefaultTypeInternal _ModelWarmup_Input_default_instance_;
constexpr ModelWarmup_InputsEntry_DoNotUse::ModelWarmup_InputsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelWarmup_InputsEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelWarmup_InputsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelWarmup_InputsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelWarmup_InputsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelWarmup_InputsEntry_DoNotUseDefaultTypeInternal _ModelWarmup_InputsEntry_DoNotUse_default_instance_;
constexpr ModelWarmup::ModelWarmup(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : inputs_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , batch_size_(0u)
  , count_(0u){}
struct ModelWarmupDefaultTypeInternal {
  constexpr ModelWarmupDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelWarmupDefaultTypeInternal() {}
  union {
    ModelWarmup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelWarmupDefaultTypeInternal _ModelWarmup_default_instance_;
constexpr ModelOperations::ModelOperations(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : op_library_filename_(){}
struct ModelOperationsDefaultTypeInternal {
  constexpr ModelOperationsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelOperationsDefaultTypeInternal() {}
  union {
    ModelOperations _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelOperationsDefaultTypeInternal _ModelOperations_default_instance_;
constexpr ModelTransactionPolicy::ModelTransactionPolicy(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : decoupled_(false){}
struct ModelTransactionPolicyDefaultTypeInternal {
  constexpr ModelTransactionPolicyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelTransactionPolicyDefaultTypeInternal() {}
  union {
    ModelTransactionPolicy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelTransactionPolicyDefaultTypeInternal _ModelTransactionPolicy_default_instance_;
constexpr ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelRepositoryAgents_Agent_ParametersEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelRepositoryAgents_Agent_ParametersEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelRepositoryAgents_Agent_ParametersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelRepositoryAgents_Agent_ParametersEntry_DoNotUseDefaultTypeInternal _ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse_default_instance_;
constexpr ModelRepositoryAgents_Agent::ModelRepositoryAgents_Agent(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : parameters_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct ModelRepositoryAgents_AgentDefaultTypeInternal {
  constexpr ModelRepositoryAgents_AgentDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelRepositoryAgents_AgentDefaultTypeInternal() {}
  union {
    ModelRepositoryAgents_Agent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelRepositoryAgents_AgentDefaultTypeInternal _ModelRepositoryAgents_Agent_default_instance_;
constexpr ModelRepositoryAgents::ModelRepositoryAgents(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : agents_(){}
struct ModelRepositoryAgentsDefaultTypeInternal {
  constexpr ModelRepositoryAgentsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelRepositoryAgentsDefaultTypeInternal() {}
  union {
    ModelRepositoryAgents _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelRepositoryAgentsDefaultTypeInternal _ModelRepositoryAgents_default_instance_;
constexpr ModelResponseCache::ModelResponseCache(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : enable_(false){}
struct ModelResponseCacheDefaultTypeInternal {
  constexpr ModelResponseCacheDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelResponseCacheDefaultTypeInternal() {}
  union {
    ModelResponseCache _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelResponseCacheDefaultTypeInternal _ModelResponseCache_default_instance_;
constexpr ModelConfig_CcModelFilenamesEntry_DoNotUse::ModelConfig_CcModelFilenamesEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelConfig_CcModelFilenamesEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelConfig_CcModelFilenamesEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelConfig_CcModelFilenamesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelConfig_CcModelFilenamesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelConfig_CcModelFilenamesEntry_DoNotUseDefaultTypeInternal _ModelConfig_CcModelFilenamesEntry_DoNotUse_default_instance_;
constexpr ModelConfig_MetricTagsEntry_DoNotUse::ModelConfig_MetricTagsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelConfig_MetricTagsEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelConfig_MetricTagsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelConfig_MetricTagsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelConfig_MetricTagsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelConfig_MetricTagsEntry_DoNotUseDefaultTypeInternal _ModelConfig_MetricTagsEntry_DoNotUse_default_instance_;
constexpr ModelConfig_ParametersEntry_DoNotUse::ModelConfig_ParametersEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelConfig_ParametersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal _ModelConfig_ParametersEntry_DoNotUse_default_instance_;
constexpr ModelConfig::ModelConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_()
  , output_()
  , instance_group_()
  , cc_model_filenames_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , metric_tags_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , parameters_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , model_warmup_()
  , batch_input_()
  , batch_output_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , platform_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , default_model_filename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , backend_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , runtime_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , version_policy_(nullptr)
  , optimization_(nullptr)
  , model_operations_(nullptr)
  , model_transaction_policy_(nullptr)
  , model_repository_agents_(nullptr)
  , response_cache_(nullptr)
  , max_batch_size_(0)
  , _oneof_case_{}{}
struct ModelConfigDefaultTypeInternal {
  constexpr ModelConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelConfigDefaultTypeInternal() {}
  union {
    ModelConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelConfigDefaultTypeInternal _ModelConfig_default_instance_;
}  // namespace inference
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_model_5fconfig_2eproto[53];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_model_5fconfig_2eproto[9];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_model_5fconfig_2eproto = nullptr;

const uint32_t TableStruct_model_5fconfig_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter_Resource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter_Resource, name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter_Resource, global_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter_Resource, count_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter, resources_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRateLimiter, priority_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup_SecondaryDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup_SecondaryDevice, kind_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup_SecondaryDevice, device_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, kind_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, count_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, rate_limiter_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, gpus_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, secondary_devices_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, profile_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, passive_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInstanceGroup, host_policy_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelTensorReshape, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelTensorReshape, shape_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, format_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, dims_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, reshape_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, is_shape_tensor_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, allow_ragged_batch_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelInput, optional_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, dims_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, reshape_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, label_filename_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOutput, is_shape_tensor_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::BatchInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::BatchInput, kind_),
  PROTOBUF_FIELD_OFFSET(::inference::BatchInput, target_name_),
  PROTOBUF_FIELD_OFFSET(::inference::BatchInput, data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::BatchInput, source_input_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::BatchOutput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::BatchOutput, target_name_),
  PROTOBUF_FIELD_OFFSET(::inference::BatchOutput, kind_),
  PROTOBUF_FIELD_OFFSET(::inference::BatchOutput, source_input_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy_Latest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy_Latest, num_versions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy_All, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy_Specific, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy_Specific, versions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::inference::ModelVersionPolicy, policy_choice_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Graph, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Graph, level_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape, dim_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound, batch_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound, input_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec, batch_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec, input_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda_GraphSpec, graph_lower_bound_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda, graphs_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda, busy_wait_events_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda, graph_spec_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_Cuda, output_copy_stream_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator, name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator, parameters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators, gpu_execution_accelerator_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_ExecutionAccelerators, cpu_execution_accelerator_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer, enable_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, graph_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, priority_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, cuda_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, execution_accelerators_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, input_pinned_memory_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, output_pinned_memory_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, gather_kernel_buffer_threshold_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelOptimizationPolicy, eager_batching_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelQueuePolicy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelQueuePolicy, timeout_action_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelQueuePolicy, default_timeout_microseconds_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelQueuePolicy, allow_timeout_override_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelQueuePolicy, max_queue_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, preferred_batch_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, max_queue_delay_microseconds_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, preserve_ordering_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, priority_levels_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, default_priority_level_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, default_queue_policy_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelDynamicBatching, priority_queue_policy_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_Control, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_Control, kind_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_Control, int32_false_true_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_Control, fp32_false_true_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_Control, bool_false_true_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_Control, data_type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_ControlInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_ControlInput, name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_ControlInput, control_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_InitialState, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_InitialState, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_InitialState, data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_InitialState, dims_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_InitialState, name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_InitialState, state_data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, input_name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, output_name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, dims_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, initial_state_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, use_same_buffer_for_input_output_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_State, use_growable_memory_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyDirect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyDirect, max_queue_delay_microseconds_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyDirect, minimum_slot_utilization_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyOldest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyOldest, max_candidate_sequences_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyOldest, preferred_batch_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyOldest, max_queue_delay_microseconds_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching_StrategyOldest, preserve_ordering_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, max_sequence_idle_microseconds_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, control_input_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, state_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, iterative_sequence_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelSequenceBatching, strategy_choice_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step, model_name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step, model_version_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step, input_map_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step, output_map_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling_Step, model_namespace_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelEnsembling, step_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelParameter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelParameter, string_value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_Input, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_Input, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_Input, data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_Input, dims_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_Input, input_data_type_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_InputsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_InputsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_InputsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup_InputsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup, name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup, batch_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup, inputs_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelWarmup, count_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOperations, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelOperations, op_library_filename_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelTransactionPolicy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelTransactionPolicy, decoupled_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent, name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents_Agent, parameters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelRepositoryAgents, agents_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelResponseCache, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelResponseCache, enable_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_MetricTagsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_MetricTagsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_MetricTagsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_MetricTagsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_ParametersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_ParametersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_ParametersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig_ParametersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, name_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, platform_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, backend_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, runtime_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, version_policy_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, max_batch_size_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, input_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, output_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, batch_input_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, batch_output_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, optimization_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, instance_group_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, default_model_filename_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, cc_model_filenames_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, metric_tags_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, parameters_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, model_warmup_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, model_operations_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, model_transaction_policy_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, model_repository_agents_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, response_cache_),
  PROTOBUF_FIELD_OFFSET(::inference::ModelConfig, scheduling_choice_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::inference::ModelRateLimiter_Resource)},
  { 9, -1, -1, sizeof(::inference::ModelRateLimiter)},
  { 17, -1, -1, sizeof(::inference::ModelInstanceGroup_SecondaryDevice)},
  { 25, -1, -1, sizeof(::inference::ModelInstanceGroup)},
  { 40, -1, -1, sizeof(::inference::ModelTensorReshape)},
  { 47, -1, -1, sizeof(::inference::ModelInput)},
  { 61, -1, -1, sizeof(::inference::ModelOutput)},
  { 73, -1, -1, sizeof(::inference::BatchInput)},
  { 83, -1, -1, sizeof(::inference::BatchOutput)},
  { 92, -1, -1, sizeof(::inference::ModelVersionPolicy_Latest)},
  { 99, -1, -1, sizeof(::inference::ModelVersionPolicy_All)},
  { 105, -1, -1, sizeof(::inference::ModelVersionPolicy_Specific)},
  { 112, -1, -1, sizeof(::inference::ModelVersionPolicy)},
  { 122, -1, -1, sizeof(::inference::ModelOptimizationPolicy_Graph)},
  { 129, -1, -1, sizeof(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape)},
  { 136, 144, -1, sizeof(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse)},
  { 146, -1, -1, sizeof(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound)},
  { 154, 162, -1, sizeof(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse)},
  { 164, -1, -1, sizeof(::inference::ModelOptimizationPolicy_Cuda_GraphSpec)},
  { 173, -1, -1, sizeof(::inference::ModelOptimizationPolicy_Cuda)},
  { 183, 191, -1, sizeof(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse)},
  { 193, -1, -1, sizeof(::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator)},
  { 201, -1, -1, sizeof(::inference::ModelOptimizationPolicy_ExecutionAccelerators)},
  { 209, -1, -1, sizeof(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer)},
  { 216, -1, -1, sizeof(::inference::ModelOptimizationPolicy)},
  { 230, -1, -1, sizeof(::inference::ModelQueuePolicy)},
  { 240, 248, -1, sizeof(::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse)},
  { 250, -1, -1, sizeof(::inference::ModelDynamicBatching)},
  { 263, -1, -1, sizeof(::inference::ModelSequenceBatching_Control)},
  { 274, -1, -1, sizeof(::inference::ModelSequenceBatching_ControlInput)},
  { 282, -1, -1, sizeof(::inference::ModelSequenceBatching_InitialState)},
  { 294, -1, -1, sizeof(::inference::ModelSequenceBatching_State)},
  { 307, -1, -1, sizeof(::inference::ModelSequenceBatching_StrategyDirect)},
  { 315, -1, -1, sizeof(::inference::ModelSequenceBatching_StrategyOldest)},
  { 325, -1, -1, sizeof(::inference::ModelSequenceBatching)},
  { 338, 346, -1, sizeof(::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse)},
  { 348, 356, -1, sizeof(::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse)},
  { 358, -1, -1, sizeof(::inference::ModelEnsembling_Step)},
  { 369, -1, -1, sizeof(::inference::ModelEnsembling)},
  { 376, -1, -1, sizeof(::inference::ModelParameter)},
  { 383, -1, -1, sizeof(::inference::ModelWarmup_Input)},
  { 395, 403, -1, sizeof(::inference::ModelWarmup_InputsEntry_DoNotUse)},
  { 405, -1, -1, sizeof(::inference::ModelWarmup)},
  { 415, -1, -1, sizeof(::inference::ModelOperations)},
  { 422, -1, -1, sizeof(::inference::ModelTransactionPolicy)},
  { 429, 437, -1, sizeof(::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse)},
  { 439, -1, -1, sizeof(::inference::ModelRepositoryAgents_Agent)},
  { 447, -1, -1, sizeof(::inference::ModelRepositoryAgents)},
  { 454, -1, -1, sizeof(::inference::ModelResponseCache)},
  { 461, 469, -1, sizeof(::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse)},
  { 471, 479, -1, sizeof(::inference::ModelConfig_MetricTagsEntry_DoNotUse)},
  { 481, 489, -1, sizeof(::inference::ModelConfig_ParametersEntry_DoNotUse)},
  { 491, -1, -1, sizeof(::inference::ModelConfig)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelRateLimiter_Resource_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelRateLimiter_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelInstanceGroup_SecondaryDevice_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelInstanceGroup_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelTensorReshape_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOutput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_BatchInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_BatchOutput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelVersionPolicy_Latest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelVersionPolicy_All_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelVersionPolicy_Specific_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelVersionPolicy_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOptimizationPolicy_Graph_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOptimizationPolicy_Cuda_GraphSpec_Shape_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOptimizationPolicy_Cuda_GraphSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOptimizationPolicy_Cuda_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOptimizationPolicy_ExecutionAccelerators_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOptimizationPolicy_PinnedMemoryBuffer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOptimizationPolicy_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelQueuePolicy_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelDynamicBatching_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelSequenceBatching_Control_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelSequenceBatching_ControlInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelSequenceBatching_InitialState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelSequenceBatching_State_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelSequenceBatching_StrategyDirect_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelSequenceBatching_StrategyOldest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelSequenceBatching_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelEnsembling_Step_InputMapEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelEnsembling_Step_OutputMapEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelEnsembling_Step_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelEnsembling_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelParameter_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelWarmup_Input_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelWarmup_InputsEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelWarmup_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelOperations_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelTransactionPolicy_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelRepositoryAgents_Agent_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelRepositoryAgents_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelResponseCache_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelConfig_CcModelFilenamesEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelConfig_MetricTagsEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelConfig_ParametersEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::inference::_ModelConfig_default_instance_),
};

const char descriptor_table_protodef_model_5fconfig_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022model_config.proto\022\tinference\"\226\001\n\020Mode"
  "lRateLimiter\0227\n\tresources\030\001 \003(\0132$.infere"
  "nce.ModelRateLimiter.Resource\022\020\n\010priorit"
  "y\030\002 \001(\r\0327\n\010Resource\022\014\n\004name\030\001 \001(\t\022\016\n\006glo"
  "bal\030\002 \001(\010\022\r\n\005count\030\003 \001(\r\"\207\004\n\022ModelInstan"
  "ceGroup\022\014\n\004name\030\001 \001(\t\0220\n\004kind\030\004 \001(\0162\".in"
  "ference.ModelInstanceGroup.Kind\022\r\n\005count"
  "\030\002 \001(\005\0221\n\014rate_limiter\030\006 \001(\0132\033.inference"
  ".ModelRateLimiter\022\014\n\004gpus\030\003 \003(\005\022H\n\021secon"
  "dary_devices\030\010 \003(\0132-.inference.ModelInst"
  "anceGroup.SecondaryDevice\022\017\n\007profile\030\005 \003"
  "(\t\022\017\n\007passive\030\007 \001(\010\022\023\n\013host_policy\030\t \001(\t"
  "\032\234\001\n\017SecondaryDevice\022O\n\004kind\030\001 \001(\0162A.inf"
  "erence.ModelInstanceGroup.SecondaryDevic"
  "e.SecondaryDeviceKind\022\021\n\tdevice_id\030\002 \001(\003"
  "\"%\n\023SecondaryDeviceKind\022\016\n\nKIND_NVDLA\020\000\""
  "A\n\004Kind\022\r\n\tKIND_AUTO\020\000\022\014\n\010KIND_GPU\020\001\022\014\n\010"
  "KIND_CPU\020\002\022\016\n\nKIND_MODEL\020\003\"#\n\022ModelTenso"
  "rReshape\022\r\n\005shape\030\001 \003(\003\"\262\002\n\nModelInput\022\014"
  "\n\004name\030\001 \001(\t\022&\n\tdata_type\030\002 \001(\0162\023.infere"
  "nce.DataType\022,\n\006format\030\003 \001(\0162\034.inference"
  ".ModelInput.Format\022\014\n\004dims\030\004 \003(\003\022.\n\007resh"
  "ape\030\005 \001(\0132\035.inference.ModelTensorReshape"
  "\022\027\n\017is_shape_tensor\030\006 \001(\010\022\032\n\022allow_ragge"
  "d_batch\030\007 \001(\010\022\020\n\010optional\030\010 \001(\010\";\n\006Forma"
  "t\022\017\n\013FORMAT_NONE\020\000\022\017\n\013FORMAT_NHWC\020\001\022\017\n\013F"
  "ORMAT_NCHW\020\002\"\262\001\n\013ModelOutput\022\014\n\004name\030\001 \001"
  "(\t\022&\n\tdata_type\030\002 \001(\0162\023.inference.DataTy"
  "pe\022\014\n\004dims\030\003 \003(\003\022.\n\007reshape\030\005 \001(\0132\035.infe"
  "rence.ModelTensorReshape\022\026\n\016label_filena"
  "me\030\004 \001(\t\022\027\n\017is_shape_tensor\030\006 \001(\010\"\331\002\n\nBa"
  "tchInput\022(\n\004kind\030\001 \001(\0162\032.inference.Batch"
  "Input.Kind\022\023\n\013target_name\030\002 \003(\t\022&\n\tdata_"
  "type\030\003 \001(\0162\023.inference.DataType\022\024\n\014sourc"
  "e_input\030\004 \003(\t\"\315\001\n\004Kind\022\027\n\023BATCH_ELEMENT_"
  "COUNT\020\000\022#\n\037BATCH_ACCUMULATED_ELEMENT_COU"
  "NT\020\001\022-\n)BATCH_ACCUMULATED_ELEMENT_COUNT_"
  "WITH_ZERO\020\002\022$\n BATCH_MAX_ELEMENT_COUNT_A"
  "S_SHAPE\020\003\022\024\n\020BATCH_ITEM_SHAPE\020\004\022\034\n\030BATCH"
  "_ITEM_SHAPE_FLATTEN\020\005\"\217\001\n\013BatchOutput\022\023\n"
  "\013target_name\030\001 \003(\t\022)\n\004kind\030\002 \001(\0162\033.infer"
  "ence.BatchOutput.Kind\022\024\n\014source_input\030\003 "
  "\003(\t\"*\n\004Kind\022\"\n\036BATCH_SCATTER_WITH_INPUT_"
  "SHAPE\020\000\"\220\002\n\022ModelVersionPolicy\0226\n\006latest"
  "\030\001 \001(\0132$.inference.ModelVersionPolicy.La"
  "testH\000\0220\n\003all\030\002 \001(\0132!.inference.ModelVer"
  "sionPolicy.AllH\000\022:\n\010specific\030\003 \001(\0132&.inf"
  "erence.ModelVersionPolicy.SpecificH\000\032\036\n\006"
  "Latest\022\024\n\014num_versions\030\001 \001(\r\032\005\n\003All\032\034\n\010S"
  "pecific\022\020\n\010versions\030\001 \003(\003B\017\n\rpolicy_choi"
  "ce\"\375\r\n\027ModelOptimizationPolicy\0227\n\005graph\030"
  "\001 \001(\0132(.inference.ModelOptimizationPolic"
  "y.Graph\022B\n\010priority\030\002 \001(\01620.inference.Mo"
  "delOptimizationPolicy.ModelPriority\0225\n\004c"
  "uda\030\003 \001(\0132\'.inference.ModelOptimizationP"
  "olicy.Cuda\022X\n\026execution_accelerators\030\004 \001"
  "(\01328.inference.ModelOptimizationPolicy.E"
  "xecutionAccelerators\022R\n\023input_pinned_mem"
  "ory\030\005 \001(\01325.inference.ModelOptimizationP"
  "olicy.PinnedMemoryBuffer\022S\n\024output_pinne"
  "d_memory\030\006 \001(\01325.inference.ModelOptimiza"
  "tionPolicy.PinnedMemoryBuffer\022&\n\036gather_"
  "kernel_buffer_threshold\030\007 \001(\r\022\026\n\016eager_b"
  "atching\030\010 \001(\010\032\026\n\005Graph\022\r\n\005level\030\001 \001(\005\032\272\005"
  "\n\004Cuda\022\016\n\006graphs\030\001 \001(\010\022\030\n\020busy_wait_even"
  "ts\030\002 \001(\010\022E\n\ngraph_spec\030\003 \003(\01321.inference"
  ".ModelOptimizationPolicy.Cuda.GraphSpec\022"
  "\032\n\022output_copy_stream\030\004 \001(\010\032\244\004\n\tGraphSpe"
  "c\022\022\n\nbatch_size\030\001 \001(\005\022K\n\005input\030\002 \003(\0132<.i"
  "nference.ModelOptimizationPolicy.Cuda.Gr"
  "aphSpec.InputEntry\022W\n\021graph_lower_bound\030"
  "\003 \001(\0132<.inference.ModelOptimizationPolic"
  "y.Cuda.GraphSpec.LowerBound\032\024\n\005Shape\022\013\n\003"
  "dim\030\001 \003(\003\032\337\001\n\nLowerBound\022\022\n\nbatch_size\030\001"
  " \001(\005\022V\n\005input\030\002 \003(\0132G.inference.ModelOpt"
  "imizationPolicy.Cuda.GraphSpec.LowerBoun"
  "d.InputEntry\032e\n\nInputEntry\022\013\n\003key\030\001 \001(\t\022"
  "F\n\005value\030\002 \001(\01327.inference.ModelOptimiza"
  "tionPolicy.Cuda.GraphSpec.Shape:\0028\001\032e\n\nI"
  "nputEntry\022\013\n\003key\030\001 \001(\t\022F\n\005value\030\002 \001(\01327."
  "inference.ModelOptimizationPolicy.Cuda.G"
  "raphSpec.Shape:\0028\001\032\244\003\n\025ExecutionAccelera"
  "tors\022g\n\031gpu_execution_accelerator\030\001 \003(\0132"
  "D.inference.ModelOptimizationPolicy.Exec"
  "utionAccelerators.Accelerator\022g\n\031cpu_exe"
  "cution_accelerator\030\002 \003(\0132D.inference.Mod"
  "elOptimizationPolicy.ExecutionAccelerato"
  "rs.Accelerator\032\270\001\n\013Accelerator\022\014\n\004name\030\001"
  " \001(\t\022h\n\nparameters\030\002 \003(\0132T.inference.Mod"
  "elOptimizationPolicy.ExecutionAccelerato"
  "rs.Accelerator.ParametersEntry\0321\n\017Parame"
  "tersEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028"
  "\001\032$\n\022PinnedMemoryBuffer\022\016\n\006enable\030\001 \001(\010\""
  "I\n\rModelPriority\022\024\n\020PRIORITY_DEFAULT\020\000\022\020"
  "\n\014PRIORITY_MAX\020\001\022\020\n\014PRIORITY_MIN\020\002\"\333\001\n\020M"
  "odelQueuePolicy\022A\n\016timeout_action\030\001 \001(\0162"
  ").inference.ModelQueuePolicy.TimeoutActi"
  "on\022$\n\034default_timeout_microseconds\030\002 \001(\004"
  "\022\036\n\026allow_timeout_override\030\003 \001(\010\022\026\n\016max_"
  "queue_size\030\004 \001(\r\"&\n\rTimeoutAction\022\n\n\006REJ"
  "ECT\020\000\022\t\n\005DELAY\020\001\"\233\003\n\024ModelDynamicBatchin"
  "g\022\034\n\024preferred_batch_size\030\001 \003(\005\022$\n\034max_q"
  "ueue_delay_microseconds\030\002 \001(\004\022\031\n\021preserv"
  "e_ordering\030\003 \001(\010\022\027\n\017priority_levels\030\004 \001("
  "\004\022\036\n\026default_priority_level\030\005 \001(\004\0229\n\024def"
  "ault_queue_policy\030\006 \001(\0132\033.inference.Mode"
  "lQueuePolicy\022W\n\025priority_queue_policy\030\007 "
  "\003(\01328.inference.ModelDynamicBatching.Pri"
  "orityQueuePolicyEntry\032W\n\030PriorityQueuePo"
  "licyEntry\022\013\n\003key\030\001 \001(\004\022*\n\005value\030\002 \001(\0132\033."
  "inference.ModelQueuePolicy:\0028\001\"\356\n\n\025Model"
  "SequenceBatching\022A\n\006direct\030\003 \001(\0132/.infer"
  "ence.ModelSequenceBatching.StrategyDirec"
  "tH\000\022A\n\006oldest\030\004 \001(\0132/.inference.ModelSeq"
  "uenceBatching.StrategyOldestH\000\022&\n\036max_se"
  "quence_idle_microseconds\030\001 \001(\004\022D\n\rcontro"
  "l_input\030\002 \003(\0132-.inference.ModelSequenceB"
  "atching.ControlInput\0225\n\005state\030\005 \003(\0132&.in"
  "ference.ModelSequenceBatching.State\022\032\n\022i"
  "terative_sequence\030\006 \001(\010\032\261\002\n\007Control\022;\n\004k"
  "ind\030\001 \001(\0162-.inference.ModelSequenceBatch"
  "ing.Control.Kind\022\030\n\020int32_false_true\030\002 \003"
  "(\005\022\027\n\017fp32_false_true\030\003 \003(\002\022\027\n\017bool_fals"
  "e_true\030\005 \003(\010\022&\n\tdata_type\030\004 \001(\0162\023.infere"
  "nce.DataType\"u\n\004Kind\022\032\n\026CONTROL_SEQUENCE"
  "_START\020\000\022\032\n\026CONTROL_SEQUENCE_READY\020\001\022\030\n\024"
  "CONTROL_SEQUENCE_END\020\002\022\033\n\027CONTROL_SEQUEN"
  "CE_CORRID\020\003\032W\n\014ControlInput\022\014\n\004name\030\001 \001("
  "\t\0229\n\007control\030\002 \003(\0132(.inference.ModelSequ"
  "enceBatching.Control\032\212\001\n\014InitialState\022&\n"
  "\tdata_type\030\001 \001(\0162\023.inference.DataType\022\014\n"
  "\004dims\030\002 \003(\003\022\023\n\tzero_data\030\003 \001(\010H\000\022\023\n\tdata"
  "_file\030\004 \001(\tH\000\022\014\n\004name\030\005 \001(\tB\014\n\nstate_dat"
  "a\032\363\001\n\005State\022\022\n\ninput_name\030\001 \001(\t\022\023\n\013outpu"
  "t_name\030\002 \001(\t\022&\n\tdata_type\030\003 \001(\0162\023.infere"
  "nce.DataType\022\014\n\004dims\030\004 \003(\003\022D\n\rinitial_st"
  "ate\030\005 \003(\0132-.inference.ModelSequenceBatch"
  "ing.InitialState\022(\n use_same_buffer_for_"
  "input_output\030\006 \001(\010\022\033\n\023use_growable_memor"
  "y\030\007 \001(\010\032X\n\016StrategyDirect\022$\n\034max_queue_d"
  "elay_microseconds\030\001 \001(\004\022 \n\030minimum_slot_"
  "utilization\030\002 \001(\002\032\220\001\n\016StrategyOldest\022\037\n\027"
  "max_candidate_sequences\030\001 \001(\005\022\034\n\024preferr"
  "ed_batch_size\030\002 \003(\005\022$\n\034max_queue_delay_m"
  "icroseconds\030\003 \001(\004\022\031\n\021preserve_ordering\030\004"
  " \001(\010B\021\n\017strategy_choice\"\366\002\n\017ModelEnsembl"
  "ing\022-\n\004step\030\001 \003(\0132\037.inference.ModelEnsem"
  "bling.Step\032\263\002\n\004Step\022\022\n\nmodel_name\030\001 \001(\t\022"
  "\025\n\rmodel_version\030\002 \001(\003\022@\n\tinput_map\030\003 \003("
  "\0132-.inference.ModelEnsembling.Step.Input"
  "MapEntry\022B\n\noutput_map\030\004 \003(\0132..inference"
  ".ModelEnsembling.Step.OutputMapEntry\022\027\n\017"
  "model_namespace\030\005 \001(\t\032/\n\rInputMapEntry\022\013"
  "\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\0320\n\016Output"
  "MapEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001"
  "\"&\n\016ModelParameter\022\024\n\014string_value\030\001 \001(\t"
  "\"\331\002\n\013ModelWarmup\022\014\n\004name\030\001 \001(\t\022\022\n\nbatch_"
  "size\030\002 \001(\r\0222\n\006inputs\030\003 \003(\0132\".inference.M"
  "odelWarmup.InputsEntry\022\r\n\005count\030\004 \001(\r\032\227\001"
  "\n\005Input\022&\n\tdata_type\030\001 \001(\0162\023.inference.D"
  "ataType\022\014\n\004dims\030\002 \003(\003\022\023\n\tzero_data\030\003 \001(\010"
  "H\000\022\025\n\013random_data\030\004 \001(\010H\000\022\031\n\017input_data_"
  "file\030\005 \001(\tH\000B\021\n\017input_data_type\032K\n\013Input"
  "sEntry\022\013\n\003key\030\001 \001(\t\022+\n\005value\030\002 \001(\0132\034.inf"
  "erence.ModelWarmup.Input:\0028\001\".\n\017ModelOpe"
  "rations\022\033\n\023op_library_filename\030\001 \003(\t\"+\n\026"
  "ModelTransactionPolicy\022\021\n\tdecoupled\030\001 \001("
  "\010\"\346\001\n\025ModelRepositoryAgents\0226\n\006agents\030\001 "
  "\003(\0132&.inference.ModelRepositoryAgents.Ag"
  "ent\032\224\001\n\005Agent\022\014\n\004name\030\001 \001(\t\022J\n\nparameter"
  "s\030\002 \003(\01326.inference.ModelRepositoryAgent"
  "s.Agent.ParametersEntry\0321\n\017ParametersEnt"
  "ry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"$\n\022Mo"
  "delResponseCache\022\016\n\006enable\030\001 \001(\010\"\303\n\n\013Mod"
  "elConfig\022\014\n\004name\030\001 \001(\t\022\020\n\010platform\030\002 \001(\t"
  "\022\017\n\007backend\030\021 \001(\t\022\017\n\007runtime\030\031 \001(\t\0225\n\016ve"
  "rsion_policy\030\003 \001(\0132\035.inference.ModelVers"
  "ionPolicy\022\026\n\016max_batch_size\030\004 \001(\005\022$\n\005inp"
  "ut\030\005 \003(\0132\025.inference.ModelInput\022&\n\006outpu"
  "t\030\006 \003(\0132\026.inference.ModelOutput\022*\n\013batch"
  "_input\030\024 \003(\0132\025.inference.BatchInput\022,\n\014b"
  "atch_output\030\025 \003(\0132\026.inference.BatchOutpu"
  "t\0228\n\014optimization\030\014 \001(\0132\".inference.Mode"
  "lOptimizationPolicy\022;\n\020dynamic_batching\030"
  "\013 \001(\0132\037.inference.ModelDynamicBatchingH\000"
  "\022=\n\021sequence_batching\030\r \001(\0132 .inference."
  "ModelSequenceBatchingH\000\0229\n\023ensemble_sche"
  "duling\030\017 \001(\0132\032.inference.ModelEnsembling"
  "H\000\0225\n\016instance_group\030\007 \003(\0132\035.inference.M"
  "odelInstanceGroup\022\036\n\026default_model_filen"
  "ame\030\010 \001(\t\022H\n\022cc_model_filenames\030\t \003(\0132,."
  "inference.ModelConfig.CcModelFilenamesEn"
  "try\022;\n\013metric_tags\030\n \003(\0132&.inference.Mod"
  "elConfig.MetricTagsEntry\022:\n\nparameters\030\016"
  " \003(\0132&.inference.ModelConfig.ParametersE"
  "ntry\022,\n\014model_warmup\030\020 \003(\0132\026.inference.M"
  "odelWarmup\0224\n\020model_operations\030\022 \001(\0132\032.i"
  "nference.ModelOperations\022C\n\030model_transa"
  "ction_policy\030\023 \001(\0132!.inference.ModelTran"
  "sactionPolicy\022A\n\027model_repository_agents"
  "\030\027 \001(\0132 .inference.ModelRepositoryAgents"
  "\0225\n\016response_cache\030\030 \001(\0132\035.inference.Mod"
  "elResponseCache\0327\n\025CcModelFilenamesEntry"
  "\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\0321\n\017Metr"
  "icTagsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:"
  "\0028\001\032L\n\017ParametersEntry\022\013\n\003key\030\001 \001(\t\022(\n\005v"
  "alue\030\002 \001(\0132\031.inference.ModelParameter:\0028"
  "\001B\023\n\021scheduling_choice*\372\001\n\010DataType\022\020\n\014T"
  "YPE_INVALID\020\000\022\r\n\tTYPE_BOOL\020\001\022\016\n\nTYPE_UIN"
  "T8\020\002\022\017\n\013TYPE_UINT16\020\003\022\017\n\013TYPE_UINT32\020\004\022\017"
  "\n\013TYPE_UINT64\020\005\022\r\n\tTYPE_INT8\020\006\022\016\n\nTYPE_I"
  "NT16\020\007\022\016\n\nTYPE_INT32\020\010\022\016\n\nTYPE_INT64\020\t\022\r"
  "\n\tTYPE_FP16\020\n\022\r\n\tTYPE_FP32\020\013\022\r\n\tTYPE_FP6"
  "4\020\014\022\017\n\013TYPE_STRING\020\r\022\r\n\tTYPE_BF16\020\016b\006pro"
  "to3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_model_5fconfig_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_model_5fconfig_2eproto = {
  false, false, 8563, descriptor_table_protodef_model_5fconfig_2eproto, "model_config.proto", 
  &descriptor_table_model_5fconfig_2eproto_once, nullptr, 0, 53,
  schemas, file_default_instances, TableStruct_model_5fconfig_2eproto::offsets,
  file_level_metadata_model_5fconfig_2eproto, file_level_enum_descriptors_model_5fconfig_2eproto, file_level_service_descriptors_model_5fconfig_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_model_5fconfig_2eproto_getter() {
  return &descriptor_table_model_5fconfig_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_model_5fconfig_2eproto(&descriptor_table_model_5fconfig_2eproto);
namespace inference {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[0];
}
bool ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind ModelInstanceGroup_SecondaryDevice::KIND_NVDLA;
constexpr ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind ModelInstanceGroup_SecondaryDevice::SecondaryDeviceKind_MIN;
constexpr ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind ModelInstanceGroup_SecondaryDevice::SecondaryDeviceKind_MAX;
constexpr int ModelInstanceGroup_SecondaryDevice::SecondaryDeviceKind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInstanceGroup_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[1];
}
bool ModelInstanceGroup_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModelInstanceGroup_Kind ModelInstanceGroup::KIND_AUTO;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup::KIND_GPU;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup::KIND_CPU;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup::KIND_MODEL;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup::Kind_MIN;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup::Kind_MAX;
constexpr int ModelInstanceGroup::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInput_Format_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[2];
}
bool ModelInput_Format_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModelInput_Format ModelInput::FORMAT_NONE;
constexpr ModelInput_Format ModelInput::FORMAT_NHWC;
constexpr ModelInput_Format ModelInput::FORMAT_NCHW;
constexpr ModelInput_Format ModelInput::Format_MIN;
constexpr ModelInput_Format ModelInput::Format_MAX;
constexpr int ModelInput::Format_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatchInput_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[3];
}
bool BatchInput_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BatchInput_Kind BatchInput::BATCH_ELEMENT_COUNT;
constexpr BatchInput_Kind BatchInput::BATCH_ACCUMULATED_ELEMENT_COUNT;
constexpr BatchInput_Kind BatchInput::BATCH_ACCUMULATED_ELEMENT_COUNT_WITH_ZERO;
constexpr BatchInput_Kind BatchInput::BATCH_MAX_ELEMENT_COUNT_AS_SHAPE;
constexpr BatchInput_Kind BatchInput::BATCH_ITEM_SHAPE;
constexpr BatchInput_Kind BatchInput::BATCH_ITEM_SHAPE_FLATTEN;
constexpr BatchInput_Kind BatchInput::Kind_MIN;
constexpr BatchInput_Kind BatchInput::Kind_MAX;
constexpr int BatchInput::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatchOutput_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[4];
}
bool BatchOutput_Kind_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BatchOutput_Kind BatchOutput::BATCH_SCATTER_WITH_INPUT_SHAPE;
constexpr BatchOutput_Kind BatchOutput::Kind_MIN;
constexpr BatchOutput_Kind BatchOutput::Kind_MAX;
constexpr int BatchOutput::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelOptimizationPolicy_ModelPriority_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[5];
}
bool ModelOptimizationPolicy_ModelPriority_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::PRIORITY_DEFAULT;
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::PRIORITY_MAX;
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::PRIORITY_MIN;
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::ModelPriority_MIN;
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::ModelPriority_MAX;
constexpr int ModelOptimizationPolicy::ModelPriority_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelQueuePolicy_TimeoutAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[6];
}
bool ModelQueuePolicy_TimeoutAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModelQueuePolicy_TimeoutAction ModelQueuePolicy::REJECT;
constexpr ModelQueuePolicy_TimeoutAction ModelQueuePolicy::DELAY;
constexpr ModelQueuePolicy_TimeoutAction ModelQueuePolicy::TimeoutAction_MIN;
constexpr ModelQueuePolicy_TimeoutAction ModelQueuePolicy::TimeoutAction_MAX;
constexpr int ModelQueuePolicy::TimeoutAction_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelSequenceBatching_Control_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[7];
}
bool ModelSequenceBatching_Control_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::CONTROL_SEQUENCE_START;
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::CONTROL_SEQUENCE_READY;
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::CONTROL_SEQUENCE_END;
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::CONTROL_SEQUENCE_CORRID;
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::Kind_MIN;
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::Kind_MAX;
constexpr int ModelSequenceBatching_Control::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_model_5fconfig_2eproto);
  return file_level_enum_descriptors_model_5fconfig_2eproto[8];
}
bool DataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class ModelRateLimiter_Resource::_Internal {
 public:
};

ModelRateLimiter_Resource::ModelRateLimiter_Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelRateLimiter.Resource)
}
ModelRateLimiter_Resource::ModelRateLimiter_Resource(const ModelRateLimiter_Resource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&global_, &from.global_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&global_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelRateLimiter.Resource)
}

inline void ModelRateLimiter_Resource::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&global_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&global_)) + sizeof(count_));
}

ModelRateLimiter_Resource::~ModelRateLimiter_Resource() {
  // @@protoc_insertion_point(destructor:inference.ModelRateLimiter.Resource)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelRateLimiter_Resource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ModelRateLimiter_Resource::ArenaDtor(void* object) {
  ModelRateLimiter_Resource* _this = reinterpret_cast< ModelRateLimiter_Resource* >(object);
  (void)_this;
}
void ModelRateLimiter_Resource::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelRateLimiter_Resource::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelRateLimiter_Resource::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelRateLimiter.Resource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  ::memset(&global_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&count_) -
      reinterpret_cast<char*>(&global_)) + sizeof(count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelRateLimiter_Resource::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelRateLimiter.Resource.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool global = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          global_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelRateLimiter_Resource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelRateLimiter.Resource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelRateLimiter.Resource.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool global = 2;
  if (this->_internal_global() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_global(), target);
  }

  // uint32 count = 3;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelRateLimiter.Resource)
  return target;
}

size_t ModelRateLimiter_Resource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelRateLimiter.Resource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool global = 2;
  if (this->_internal_global() != 0) {
    total_size += 1 + 1;
  }

  // uint32 count = 3;
  if (this->_internal_count() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelRateLimiter_Resource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelRateLimiter_Resource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelRateLimiter_Resource::GetClassData() const { return &_class_data_; }

void ModelRateLimiter_Resource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelRateLimiter_Resource *>(to)->MergeFrom(
      static_cast<const ModelRateLimiter_Resource &>(from));
}


void ModelRateLimiter_Resource::MergeFrom(const ModelRateLimiter_Resource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelRateLimiter.Resource)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_global() != 0) {
    _internal_set_global(from._internal_global());
  }
  if (from._internal_count() != 0) {
    _internal_set_count(from._internal_count());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelRateLimiter_Resource::CopyFrom(const ModelRateLimiter_Resource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelRateLimiter.Resource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelRateLimiter_Resource::IsInitialized() const {
  return true;
}

void ModelRateLimiter_Resource::InternalSwap(ModelRateLimiter_Resource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelRateLimiter_Resource, count_)
      + sizeof(ModelRateLimiter_Resource::count_)
      - PROTOBUF_FIELD_OFFSET(ModelRateLimiter_Resource, global_)>(
          reinterpret_cast<char*>(&global_),
          reinterpret_cast<char*>(&other->global_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelRateLimiter_Resource::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[0]);
}

// ===================================================================

class ModelRateLimiter::_Internal {
 public:
};

ModelRateLimiter::ModelRateLimiter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  resources_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelRateLimiter)
}
ModelRateLimiter::ModelRateLimiter(const ModelRateLimiter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      resources_(from.resources_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  priority_ = from.priority_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelRateLimiter)
}

inline void ModelRateLimiter::SharedCtor() {
priority_ = 0u;
}

ModelRateLimiter::~ModelRateLimiter() {
  // @@protoc_insertion_point(destructor:inference.ModelRateLimiter)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelRateLimiter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelRateLimiter::ArenaDtor(void* object) {
  ModelRateLimiter* _this = reinterpret_cast< ModelRateLimiter* >(object);
  (void)_this;
}
void ModelRateLimiter::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelRateLimiter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelRateLimiter::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelRateLimiter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  resources_.Clear();
  priority_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelRateLimiter::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .inference.ModelRateLimiter.Resource resources = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_resources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelRateLimiter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelRateLimiter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .inference.ModelRateLimiter.Resource resources = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_resources_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_resources(i), target, stream);
  }

  // uint32 priority = 2;
  if (this->_internal_priority() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_priority(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelRateLimiter)
  return target;
}

size_t ModelRateLimiter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelRateLimiter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelRateLimiter.Resource resources = 1;
  total_size += 1UL * this->_internal_resources_size();
  for (const auto& msg : this->resources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 priority = 2;
  if (this->_internal_priority() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_priority());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelRateLimiter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelRateLimiter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelRateLimiter::GetClassData() const { return &_class_data_; }

void ModelRateLimiter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelRateLimiter *>(to)->MergeFrom(
      static_cast<const ModelRateLimiter &>(from));
}


void ModelRateLimiter::MergeFrom(const ModelRateLimiter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelRateLimiter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  resources_.MergeFrom(from.resources_);
  if (from._internal_priority() != 0) {
    _internal_set_priority(from._internal_priority());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelRateLimiter::CopyFrom(const ModelRateLimiter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelRateLimiter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelRateLimiter::IsInitialized() const {
  return true;
}

void ModelRateLimiter::InternalSwap(ModelRateLimiter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  resources_.InternalSwap(&other->resources_);
  swap(priority_, other->priority_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelRateLimiter::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[1]);
}

// ===================================================================

class ModelInstanceGroup_SecondaryDevice::_Internal {
 public:
};

ModelInstanceGroup_SecondaryDevice::ModelInstanceGroup_SecondaryDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelInstanceGroup.SecondaryDevice)
}
ModelInstanceGroup_SecondaryDevice::ModelInstanceGroup_SecondaryDevice(const ModelInstanceGroup_SecondaryDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&device_id_, &from.device_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&kind_) -
    reinterpret_cast<char*>(&device_id_)) + sizeof(kind_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelInstanceGroup.SecondaryDevice)
}

inline void ModelInstanceGroup_SecondaryDevice::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&device_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&kind_) -
    reinterpret_cast<char*>(&device_id_)) + sizeof(kind_));
}

ModelInstanceGroup_SecondaryDevice::~ModelInstanceGroup_SecondaryDevice() {
  // @@protoc_insertion_point(destructor:inference.ModelInstanceGroup.SecondaryDevice)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelInstanceGroup_SecondaryDevice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelInstanceGroup_SecondaryDevice::ArenaDtor(void* object) {
  ModelInstanceGroup_SecondaryDevice* _this = reinterpret_cast< ModelInstanceGroup_SecondaryDevice* >(object);
  (void)_this;
}
void ModelInstanceGroup_SecondaryDevice::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelInstanceGroup_SecondaryDevice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelInstanceGroup_SecondaryDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelInstanceGroup.SecondaryDevice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&device_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&kind_) -
      reinterpret_cast<char*>(&device_id_)) + sizeof(kind_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelInstanceGroup_SecondaryDevice::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.ModelInstanceGroup.SecondaryDevice.SecondaryDeviceKind kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_kind(static_cast<::inference::ModelInstanceGroup_SecondaryDevice_SecondaryDeviceKind>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 device_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelInstanceGroup_SecondaryDevice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelInstanceGroup.SecondaryDevice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.ModelInstanceGroup.SecondaryDevice.SecondaryDeviceKind kind = 1;
  if (this->_internal_kind() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // int64 device_id = 2;
  if (this->_internal_device_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_device_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelInstanceGroup.SecondaryDevice)
  return target;
}

size_t ModelInstanceGroup_SecondaryDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelInstanceGroup.SecondaryDevice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 device_id = 2;
  if (this->_internal_device_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_device_id());
  }

  // .inference.ModelInstanceGroup.SecondaryDevice.SecondaryDeviceKind kind = 1;
  if (this->_internal_kind() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_kind());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelInstanceGroup_SecondaryDevice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelInstanceGroup_SecondaryDevice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelInstanceGroup_SecondaryDevice::GetClassData() const { return &_class_data_; }

void ModelInstanceGroup_SecondaryDevice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelInstanceGroup_SecondaryDevice *>(to)->MergeFrom(
      static_cast<const ModelInstanceGroup_SecondaryDevice &>(from));
}


void ModelInstanceGroup_SecondaryDevice::MergeFrom(const ModelInstanceGroup_SecondaryDevice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelInstanceGroup.SecondaryDevice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_device_id() != 0) {
    _internal_set_device_id(from._internal_device_id());
  }
  if (from._internal_kind() != 0) {
    _internal_set_kind(from._internal_kind());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelInstanceGroup_SecondaryDevice::CopyFrom(const ModelInstanceGroup_SecondaryDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelInstanceGroup.SecondaryDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInstanceGroup_SecondaryDevice::IsInitialized() const {
  return true;
}

void ModelInstanceGroup_SecondaryDevice::InternalSwap(ModelInstanceGroup_SecondaryDevice* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelInstanceGroup_SecondaryDevice, kind_)
      + sizeof(ModelInstanceGroup_SecondaryDevice::kind_)
      - PROTOBUF_FIELD_OFFSET(ModelInstanceGroup_SecondaryDevice, device_id_)>(
          reinterpret_cast<char*>(&device_id_),
          reinterpret_cast<char*>(&other->device_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelInstanceGroup_SecondaryDevice::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[2]);
}

// ===================================================================

class ModelInstanceGroup::_Internal {
 public:
  static const ::inference::ModelRateLimiter& rate_limiter(const ModelInstanceGroup* msg);
};

const ::inference::ModelRateLimiter&
ModelInstanceGroup::_Internal::rate_limiter(const ModelInstanceGroup* msg) {
  return *msg->rate_limiter_;
}
ModelInstanceGroup::ModelInstanceGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  gpus_(arena),
  profile_(arena),
  secondary_devices_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelInstanceGroup)
}
ModelInstanceGroup::ModelInstanceGroup(const ModelInstanceGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      gpus_(from.gpus_),
      profile_(from.profile_),
      secondary_devices_(from.secondary_devices_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  host_policy_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    host_policy_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_host_policy().empty()) {
    host_policy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_host_policy(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rate_limiter()) {
    rate_limiter_ = new ::inference::ModelRateLimiter(*from.rate_limiter_);
  } else {
    rate_limiter_ = nullptr;
  }
  ::memcpy(&count_, &from.count_,
    static_cast<size_t>(reinterpret_cast<char*>(&passive_) -
    reinterpret_cast<char*>(&count_)) + sizeof(passive_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelInstanceGroup)
}

inline void ModelInstanceGroup::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
host_policy_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  host_policy_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rate_limiter_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&passive_) -
    reinterpret_cast<char*>(&rate_limiter_)) + sizeof(passive_));
}

ModelInstanceGroup::~ModelInstanceGroup() {
  // @@protoc_insertion_point(destructor:inference.ModelInstanceGroup)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelInstanceGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  host_policy_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete rate_limiter_;
}

void ModelInstanceGroup::ArenaDtor(void* object) {
  ModelInstanceGroup* _this = reinterpret_cast< ModelInstanceGroup* >(object);
  (void)_this;
}
void ModelInstanceGroup::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelInstanceGroup::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelInstanceGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelInstanceGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  gpus_.Clear();
  profile_.Clear();
  secondary_devices_.Clear();
  name_.ClearToEmpty();
  host_policy_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && rate_limiter_ != nullptr) {
    delete rate_limiter_;
  }
  rate_limiter_ = nullptr;
  ::memset(&count_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&passive_) -
      reinterpret_cast<char*>(&count_)) + sizeof(passive_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelInstanceGroup::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelInstanceGroup.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 gpus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_gpus(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_gpus(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelInstanceGroup.Kind kind = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_kind(static_cast<::inference::ModelInstanceGroup_Kind>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string profile = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_profile();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelInstanceGroup.profile"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelRateLimiter rate_limiter = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_rate_limiter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool passive = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          passive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelInstanceGroup.SecondaryDevice secondary_devices = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_secondary_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string host_policy = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_host_policy();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelInstanceGroup.host_policy"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelInstanceGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelInstanceGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelInstanceGroup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // int32 count = 2;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_count(), target);
  }

  // repeated int32 gpus = 3;
  {
    int byte_size = _gpus_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          3, _internal_gpus(), byte_size, target);
    }
  }

  // .inference.ModelInstanceGroup.Kind kind = 4;
  if (this->_internal_kind() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_kind(), target);
  }

  // repeated string profile = 5;
  for (int i = 0, n = this->_internal_profile_size(); i < n; i++) {
    const auto& s = this->_internal_profile(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelInstanceGroup.profile");
    target = stream->WriteString(5, s, target);
  }

  // .inference.ModelRateLimiter rate_limiter = 6;
  if (this->_internal_has_rate_limiter()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::rate_limiter(this), target, stream);
  }

  // bool passive = 7;
  if (this->_internal_passive() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_passive(), target);
  }

  // repeated .inference.ModelInstanceGroup.SecondaryDevice secondary_devices = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_secondary_devices_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_secondary_devices(i), target, stream);
  }

  // string host_policy = 9;
  if (!this->_internal_host_policy().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_host_policy().data(), static_cast<int>(this->_internal_host_policy().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelInstanceGroup.host_policy");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_host_policy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelInstanceGroup)
  return target;
}

size_t ModelInstanceGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelInstanceGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 gpus = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->gpus_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _gpus_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated string profile = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(profile_.size());
  for (int i = 0, n = profile_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      profile_.Get(i));
  }

  // repeated .inference.ModelInstanceGroup.SecondaryDevice secondary_devices = 8;
  total_size += 1UL * this->_internal_secondary_devices_size();
  for (const auto& msg : this->secondary_devices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string host_policy = 9;
  if (!this->_internal_host_policy().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_host_policy());
  }

  // .inference.ModelRateLimiter rate_limiter = 6;
  if (this->_internal_has_rate_limiter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rate_limiter_);
  }

  // int32 count = 2;
  if (this->_internal_count() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_count());
  }

  // .inference.ModelInstanceGroup.Kind kind = 4;
  if (this->_internal_kind() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_kind());
  }

  // bool passive = 7;
  if (this->_internal_passive() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelInstanceGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelInstanceGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelInstanceGroup::GetClassData() const { return &_class_data_; }

void ModelInstanceGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelInstanceGroup *>(to)->MergeFrom(
      static_cast<const ModelInstanceGroup &>(from));
}


void ModelInstanceGroup::MergeFrom(const ModelInstanceGroup& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelInstanceGroup)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  gpus_.MergeFrom(from.gpus_);
  profile_.MergeFrom(from.profile_);
  secondary_devices_.MergeFrom(from.secondary_devices_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (!from._internal_host_policy().empty()) {
    _internal_set_host_policy(from._internal_host_policy());
  }
  if (from._internal_has_rate_limiter()) {
    _internal_mutable_rate_limiter()->::inference::ModelRateLimiter::MergeFrom(from._internal_rate_limiter());
  }
  if (from._internal_count() != 0) {
    _internal_set_count(from._internal_count());
  }
  if (from._internal_kind() != 0) {
    _internal_set_kind(from._internal_kind());
  }
  if (from._internal_passive() != 0) {
    _internal_set_passive(from._internal_passive());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelInstanceGroup::CopyFrom(const ModelInstanceGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelInstanceGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInstanceGroup::IsInitialized() const {
  return true;
}

void ModelInstanceGroup::InternalSwap(ModelInstanceGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  gpus_.InternalSwap(&other->gpus_);
  profile_.InternalSwap(&other->profile_);
  secondary_devices_.InternalSwap(&other->secondary_devices_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &host_policy_, lhs_arena,
      &other->host_policy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelInstanceGroup, passive_)
      + sizeof(ModelInstanceGroup::passive_)
      - PROTOBUF_FIELD_OFFSET(ModelInstanceGroup, rate_limiter_)>(
          reinterpret_cast<char*>(&rate_limiter_),
          reinterpret_cast<char*>(&other->rate_limiter_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelInstanceGroup::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[3]);
}

// ===================================================================

class ModelTensorReshape::_Internal {
 public:
};

ModelTensorReshape::ModelTensorReshape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  shape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelTensorReshape)
}
ModelTensorReshape::ModelTensorReshape(const ModelTensorReshape& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      shape_(from.shape_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelTensorReshape)
}

inline void ModelTensorReshape::SharedCtor() {
}

ModelTensorReshape::~ModelTensorReshape() {
  // @@protoc_insertion_point(destructor:inference.ModelTensorReshape)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelTensorReshape::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelTensorReshape::ArenaDtor(void* object) {
  ModelTensorReshape* _this = reinterpret_cast< ModelTensorReshape* >(object);
  (void)_this;
}
void ModelTensorReshape::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelTensorReshape::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelTensorReshape::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelTensorReshape)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shape_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelTensorReshape::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 shape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_shape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_shape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelTensorReshape::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelTensorReshape)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 shape = 1;
  {
    int byte_size = _shape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_shape(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelTensorReshape)
  return target;
}

size_t ModelTensorReshape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelTensorReshape)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 shape = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->shape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _shape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelTensorReshape::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelTensorReshape::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelTensorReshape::GetClassData() const { return &_class_data_; }

void ModelTensorReshape::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelTensorReshape *>(to)->MergeFrom(
      static_cast<const ModelTensorReshape &>(from));
}


void ModelTensorReshape::MergeFrom(const ModelTensorReshape& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelTensorReshape)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  shape_.MergeFrom(from.shape_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelTensorReshape::CopyFrom(const ModelTensorReshape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelTensorReshape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelTensorReshape::IsInitialized() const {
  return true;
}

void ModelTensorReshape::InternalSwap(ModelTensorReshape* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  shape_.InternalSwap(&other->shape_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelTensorReshape::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[4]);
}

// ===================================================================

class ModelInput::_Internal {
 public:
  static const ::inference::ModelTensorReshape& reshape(const ModelInput* msg);
};

const ::inference::ModelTensorReshape&
ModelInput::_Internal::reshape(const ModelInput* msg) {
  return *msg->reshape_;
}
ModelInput::ModelInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  dims_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelInput)
}
ModelInput::ModelInput(const ModelInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      dims_(from.dims_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_reshape()) {
    reshape_ = new ::inference::ModelTensorReshape(*from.reshape_);
  } else {
    reshape_ = nullptr;
  }
  ::memcpy(&data_type_, &from.data_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&optional_) -
    reinterpret_cast<char*>(&data_type_)) + sizeof(optional_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelInput)
}

inline void ModelInput::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&reshape_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&optional_) -
    reinterpret_cast<char*>(&reshape_)) + sizeof(optional_));
}

ModelInput::~ModelInput() {
  // @@protoc_insertion_point(destructor:inference.ModelInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete reshape_;
}

void ModelInput::ArenaDtor(void* object) {
  ModelInput* _this = reinterpret_cast< ModelInput* >(object);
  (void)_this;
}
void ModelInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelInput::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && reshape_ != nullptr) {
    delete reshape_;
  }
  reshape_ = nullptr;
  ::memset(&data_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&optional_) -
      reinterpret_cast<char*>(&data_type_)) + sizeof(optional_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelInput.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.DataType data_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelInput.Format format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_format(static_cast<::inference::ModelInput_Format>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 dims = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelTensorReshape reshape = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_reshape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_shape_tensor = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          is_shape_tensor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_ragged_batch = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          allow_ragged_batch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool optional = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelInput.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .inference.DataType data_type = 2;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_data_type(), target);
  }

  // .inference.ModelInput.Format format = 3;
  if (this->_internal_format() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_format(), target);
  }

  // repeated int64 dims = 4;
  {
    int byte_size = _dims_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          4, _internal_dims(), byte_size, target);
    }
  }

  // .inference.ModelTensorReshape reshape = 5;
  if (this->_internal_has_reshape()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::reshape(this), target, stream);
  }

  // bool is_shape_tensor = 6;
  if (this->_internal_is_shape_tensor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_is_shape_tensor(), target);
  }

  // bool allow_ragged_batch = 7;
  if (this->_internal_allow_ragged_batch() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_allow_ragged_batch(), target);
  }

  // bool optional = 8;
  if (this->_internal_optional() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_optional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelInput)
  return target;
}

size_t ModelInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->dims_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _dims_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .inference.ModelTensorReshape reshape = 5;
  if (this->_internal_has_reshape()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *reshape_);
  }

  // .inference.DataType data_type = 2;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  // .inference.ModelInput.Format format = 3;
  if (this->_internal_format() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_format());
  }

  // bool is_shape_tensor = 6;
  if (this->_internal_is_shape_tensor() != 0) {
    total_size += 1 + 1;
  }

  // bool allow_ragged_batch = 7;
  if (this->_internal_allow_ragged_batch() != 0) {
    total_size += 1 + 1;
  }

  // bool optional = 8;
  if (this->_internal_optional() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelInput::GetClassData() const { return &_class_data_; }

void ModelInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelInput *>(to)->MergeFrom(
      static_cast<const ModelInput &>(from));
}


void ModelInput::MergeFrom(const ModelInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_reshape()) {
    _internal_mutable_reshape()->::inference::ModelTensorReshape::MergeFrom(from._internal_reshape());
  }
  if (from._internal_data_type() != 0) {
    _internal_set_data_type(from._internal_data_type());
  }
  if (from._internal_format() != 0) {
    _internal_set_format(from._internal_format());
  }
  if (from._internal_is_shape_tensor() != 0) {
    _internal_set_is_shape_tensor(from._internal_is_shape_tensor());
  }
  if (from._internal_allow_ragged_batch() != 0) {
    _internal_set_allow_ragged_batch(from._internal_allow_ragged_batch());
  }
  if (from._internal_optional() != 0) {
    _internal_set_optional(from._internal_optional());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelInput::CopyFrom(const ModelInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInput::IsInitialized() const {
  return true;
}

void ModelInput::InternalSwap(ModelInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  dims_.InternalSwap(&other->dims_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelInput, optional_)
      + sizeof(ModelInput::optional_)
      - PROTOBUF_FIELD_OFFSET(ModelInput, reshape_)>(
          reinterpret_cast<char*>(&reshape_),
          reinterpret_cast<char*>(&other->reshape_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[5]);
}

// ===================================================================

class ModelOutput::_Internal {
 public:
  static const ::inference::ModelTensorReshape& reshape(const ModelOutput* msg);
};

const ::inference::ModelTensorReshape&
ModelOutput::_Internal::reshape(const ModelOutput* msg) {
  return *msg->reshape_;
}
ModelOutput::ModelOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  dims_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOutput)
}
ModelOutput::ModelOutput(const ModelOutput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      dims_(from.dims_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  label_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    label_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_label_filename().empty()) {
    label_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_label_filename(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_reshape()) {
    reshape_ = new ::inference::ModelTensorReshape(*from.reshape_);
  } else {
    reshape_ = nullptr;
  }
  ::memcpy(&data_type_, &from.data_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_shape_tensor_) -
    reinterpret_cast<char*>(&data_type_)) + sizeof(is_shape_tensor_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelOutput)
}

inline void ModelOutput::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
label_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  label_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&reshape_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_shape_tensor_) -
    reinterpret_cast<char*>(&reshape_)) + sizeof(is_shape_tensor_));
}

ModelOutput::~ModelOutput() {
  // @@protoc_insertion_point(destructor:inference.ModelOutput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelOutput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  label_filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete reshape_;
}

void ModelOutput::ArenaDtor(void* object) {
  ModelOutput* _this = reinterpret_cast< ModelOutput* >(object);
  (void)_this;
}
void ModelOutput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelOutput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelOutput::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOutput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  name_.ClearToEmpty();
  label_filename_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && reshape_ != nullptr) {
    delete reshape_;
  }
  reshape_ = nullptr;
  ::memset(&data_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_shape_tensor_) -
      reinterpret_cast<char*>(&data_type_)) + sizeof(is_shape_tensor_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOutput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelOutput.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.DataType data_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 dims = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string label_filename = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_label_filename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelOutput.label_filename"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelTensorReshape reshape = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_reshape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_shape_tensor = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          is_shape_tensor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOutput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOutput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelOutput.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .inference.DataType data_type = 2;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_data_type(), target);
  }

  // repeated int64 dims = 3;
  {
    int byte_size = _dims_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          3, _internal_dims(), byte_size, target);
    }
  }

  // string label_filename = 4;
  if (!this->_internal_label_filename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_label_filename().data(), static_cast<int>(this->_internal_label_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelOutput.label_filename");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_label_filename(), target);
  }

  // .inference.ModelTensorReshape reshape = 5;
  if (this->_internal_has_reshape()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::reshape(this), target, stream);
  }

  // bool is_shape_tensor = 6;
  if (this->_internal_is_shape_tensor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_is_shape_tensor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOutput)
  return target;
}

size_t ModelOutput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOutput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->dims_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _dims_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string label_filename = 4;
  if (!this->_internal_label_filename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_label_filename());
  }

  // .inference.ModelTensorReshape reshape = 5;
  if (this->_internal_has_reshape()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *reshape_);
  }

  // .inference.DataType data_type = 2;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  // bool is_shape_tensor = 6;
  if (this->_internal_is_shape_tensor() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOutput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelOutput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOutput::GetClassData() const { return &_class_data_; }

void ModelOutput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelOutput *>(to)->MergeFrom(
      static_cast<const ModelOutput &>(from));
}


void ModelOutput::MergeFrom(const ModelOutput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOutput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (!from._internal_label_filename().empty()) {
    _internal_set_label_filename(from._internal_label_filename());
  }
  if (from._internal_has_reshape()) {
    _internal_mutable_reshape()->::inference::ModelTensorReshape::MergeFrom(from._internal_reshape());
  }
  if (from._internal_data_type() != 0) {
    _internal_set_data_type(from._internal_data_type());
  }
  if (from._internal_is_shape_tensor() != 0) {
    _internal_set_is_shape_tensor(from._internal_is_shape_tensor());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOutput::CopyFrom(const ModelOutput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOutput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOutput::IsInitialized() const {
  return true;
}

void ModelOutput::InternalSwap(ModelOutput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  dims_.InternalSwap(&other->dims_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &label_filename_, lhs_arena,
      &other->label_filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelOutput, is_shape_tensor_)
      + sizeof(ModelOutput::is_shape_tensor_)
      - PROTOBUF_FIELD_OFFSET(ModelOutput, reshape_)>(
          reinterpret_cast<char*>(&reshape_),
          reinterpret_cast<char*>(&other->reshape_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOutput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[6]);
}

// ===================================================================

class BatchInput::_Internal {
 public:
};

BatchInput::BatchInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  target_name_(arena),
  source_input_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.BatchInput)
}
BatchInput::BatchInput(const BatchInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      target_name_(from.target_name_),
      source_input_(from.source_input_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&kind_, &from.kind_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_type_) -
    reinterpret_cast<char*>(&kind_)) + sizeof(data_type_));
  // @@protoc_insertion_point(copy_constructor:inference.BatchInput)
}

inline void BatchInput::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&kind_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&data_type_) -
    reinterpret_cast<char*>(&kind_)) + sizeof(data_type_));
}

BatchInput::~BatchInput() {
  // @@protoc_insertion_point(destructor:inference.BatchInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BatchInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BatchInput::ArenaDtor(void* object) {
  BatchInput* _this = reinterpret_cast< BatchInput* >(object);
  (void)_this;
}
void BatchInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BatchInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BatchInput::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.BatchInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  target_name_.Clear();
  source_input_.Clear();
  ::memset(&kind_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&data_type_) -
      reinterpret_cast<char*>(&kind_)) + sizeof(data_type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.BatchInput.Kind kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_kind(static_cast<::inference::BatchInput_Kind>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string target_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_target_name();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.BatchInput.target_name"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.DataType data_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string source_input = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_source_input();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.BatchInput.source_input"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.BatchInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.BatchInput.Kind kind = 1;
  if (this->_internal_kind() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // repeated string target_name = 2;
  for (int i = 0, n = this->_internal_target_name_size(); i < n; i++) {
    const auto& s = this->_internal_target_name(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.BatchInput.target_name");
    target = stream->WriteString(2, s, target);
  }

  // .inference.DataType data_type = 3;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_data_type(), target);
  }

  // repeated string source_input = 4;
  for (int i = 0, n = this->_internal_source_input_size(); i < n; i++) {
    const auto& s = this->_internal_source_input(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.BatchInput.source_input");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.BatchInput)
  return target;
}

size_t BatchInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.BatchInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string target_name = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(target_name_.size());
  for (int i = 0, n = target_name_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      target_name_.Get(i));
  }

  // repeated string source_input = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(source_input_.size());
  for (int i = 0, n = source_input_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      source_input_.Get(i));
  }

  // .inference.BatchInput.Kind kind = 1;
  if (this->_internal_kind() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_kind());
  }

  // .inference.DataType data_type = 3;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BatchInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchInput::GetClassData() const { return &_class_data_; }

void BatchInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BatchInput *>(to)->MergeFrom(
      static_cast<const BatchInput &>(from));
}


void BatchInput::MergeFrom(const BatchInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.BatchInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  target_name_.MergeFrom(from.target_name_);
  source_input_.MergeFrom(from.source_input_);
  if (from._internal_kind() != 0) {
    _internal_set_kind(from._internal_kind());
  }
  if (from._internal_data_type() != 0) {
    _internal_set_data_type(from._internal_data_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchInput::CopyFrom(const BatchInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.BatchInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchInput::IsInitialized() const {
  return true;
}

void BatchInput::InternalSwap(BatchInput* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  target_name_.InternalSwap(&other->target_name_);
  source_input_.InternalSwap(&other->source_input_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BatchInput, data_type_)
      + sizeof(BatchInput::data_type_)
      - PROTOBUF_FIELD_OFFSET(BatchInput, kind_)>(
          reinterpret_cast<char*>(&kind_),
          reinterpret_cast<char*>(&other->kind_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[7]);
}

// ===================================================================

class BatchOutput::_Internal {
 public:
};

BatchOutput::BatchOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  target_name_(arena),
  source_input_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.BatchOutput)
}
BatchOutput::BatchOutput(const BatchOutput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      target_name_(from.target_name_),
      source_input_(from.source_input_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  kind_ = from.kind_;
  // @@protoc_insertion_point(copy_constructor:inference.BatchOutput)
}

inline void BatchOutput::SharedCtor() {
kind_ = 0;
}

BatchOutput::~BatchOutput() {
  // @@protoc_insertion_point(destructor:inference.BatchOutput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BatchOutput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BatchOutput::ArenaDtor(void* object) {
  BatchOutput* _this = reinterpret_cast< BatchOutput* >(object);
  (void)_this;
}
void BatchOutput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BatchOutput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BatchOutput::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.BatchOutput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  target_name_.Clear();
  source_input_.Clear();
  kind_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchOutput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string target_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_target_name();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.BatchOutput.target_name"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.BatchOutput.Kind kind = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_kind(static_cast<::inference::BatchOutput_Kind>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string source_input = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_source_input();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.BatchOutput.source_input"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchOutput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.BatchOutput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string target_name = 1;
  for (int i = 0, n = this->_internal_target_name_size(); i < n; i++) {
    const auto& s = this->_internal_target_name(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.BatchOutput.target_name");
    target = stream->WriteString(1, s, target);
  }

  // .inference.BatchOutput.Kind kind = 2;
  if (this->_internal_kind() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_kind(), target);
  }

  // repeated string source_input = 3;
  for (int i = 0, n = this->_internal_source_input_size(); i < n; i++) {
    const auto& s = this->_internal_source_input(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.BatchOutput.source_input");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.BatchOutput)
  return target;
}

size_t BatchOutput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.BatchOutput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string target_name = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(target_name_.size());
  for (int i = 0, n = target_name_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      target_name_.Get(i));
  }

  // repeated string source_input = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(source_input_.size());
  for (int i = 0, n = source_input_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      source_input_.Get(i));
  }

  // .inference.BatchOutput.Kind kind = 2;
  if (this->_internal_kind() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_kind());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchOutput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BatchOutput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchOutput::GetClassData() const { return &_class_data_; }

void BatchOutput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BatchOutput *>(to)->MergeFrom(
      static_cast<const BatchOutput &>(from));
}


void BatchOutput::MergeFrom(const BatchOutput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.BatchOutput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  target_name_.MergeFrom(from.target_name_);
  source_input_.MergeFrom(from.source_input_);
  if (from._internal_kind() != 0) {
    _internal_set_kind(from._internal_kind());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchOutput::CopyFrom(const BatchOutput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.BatchOutput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchOutput::IsInitialized() const {
  return true;
}

void BatchOutput::InternalSwap(BatchOutput* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  target_name_.InternalSwap(&other->target_name_);
  source_input_.InternalSwap(&other->source_input_);
  swap(kind_, other->kind_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchOutput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[8]);
}

// ===================================================================

class ModelVersionPolicy_Latest::_Internal {
 public:
};

ModelVersionPolicy_Latest::ModelVersionPolicy_Latest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelVersionPolicy.Latest)
}
ModelVersionPolicy_Latest::ModelVersionPolicy_Latest(const ModelVersionPolicy_Latest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  num_versions_ = from.num_versions_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelVersionPolicy.Latest)
}

inline void ModelVersionPolicy_Latest::SharedCtor() {
num_versions_ = 0u;
}

ModelVersionPolicy_Latest::~ModelVersionPolicy_Latest() {
  // @@protoc_insertion_point(destructor:inference.ModelVersionPolicy.Latest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelVersionPolicy_Latest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelVersionPolicy_Latest::ArenaDtor(void* object) {
  ModelVersionPolicy_Latest* _this = reinterpret_cast< ModelVersionPolicy_Latest* >(object);
  (void)_this;
}
void ModelVersionPolicy_Latest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelVersionPolicy_Latest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelVersionPolicy_Latest::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelVersionPolicy.Latest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  num_versions_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelVersionPolicy_Latest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 num_versions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          num_versions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelVersionPolicy_Latest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelVersionPolicy.Latest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 num_versions = 1;
  if (this->_internal_num_versions() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num_versions(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelVersionPolicy.Latest)
  return target;
}

size_t ModelVersionPolicy_Latest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelVersionPolicy.Latest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 num_versions = 1;
  if (this->_internal_num_versions() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_num_versions());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelVersionPolicy_Latest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelVersionPolicy_Latest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelVersionPolicy_Latest::GetClassData() const { return &_class_data_; }

void ModelVersionPolicy_Latest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelVersionPolicy_Latest *>(to)->MergeFrom(
      static_cast<const ModelVersionPolicy_Latest &>(from));
}


void ModelVersionPolicy_Latest::MergeFrom(const ModelVersionPolicy_Latest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelVersionPolicy.Latest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_num_versions() != 0) {
    _internal_set_num_versions(from._internal_num_versions());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelVersionPolicy_Latest::CopyFrom(const ModelVersionPolicy_Latest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelVersionPolicy.Latest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelVersionPolicy_Latest::IsInitialized() const {
  return true;
}

void ModelVersionPolicy_Latest::InternalSwap(ModelVersionPolicy_Latest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(num_versions_, other->num_versions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelVersionPolicy_Latest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[9]);
}

// ===================================================================

class ModelVersionPolicy_All::_Internal {
 public:
};

ModelVersionPolicy_All::ModelVersionPolicy_All(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:inference.ModelVersionPolicy.All)
}
ModelVersionPolicy_All::ModelVersionPolicy_All(const ModelVersionPolicy_All& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelVersionPolicy.All)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelVersionPolicy_All::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelVersionPolicy_All::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ModelVersionPolicy_All::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[10]);
}

// ===================================================================

class ModelVersionPolicy_Specific::_Internal {
 public:
};

ModelVersionPolicy_Specific::ModelVersionPolicy_Specific(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  versions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelVersionPolicy.Specific)
}
ModelVersionPolicy_Specific::ModelVersionPolicy_Specific(const ModelVersionPolicy_Specific& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      versions_(from.versions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelVersionPolicy.Specific)
}

inline void ModelVersionPolicy_Specific::SharedCtor() {
}

ModelVersionPolicy_Specific::~ModelVersionPolicy_Specific() {
  // @@protoc_insertion_point(destructor:inference.ModelVersionPolicy.Specific)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelVersionPolicy_Specific::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelVersionPolicy_Specific::ArenaDtor(void* object) {
  ModelVersionPolicy_Specific* _this = reinterpret_cast< ModelVersionPolicy_Specific* >(object);
  (void)_this;
}
void ModelVersionPolicy_Specific::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelVersionPolicy_Specific::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelVersionPolicy_Specific::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelVersionPolicy.Specific)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  versions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelVersionPolicy_Specific::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 versions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_versions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_versions(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelVersionPolicy_Specific::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelVersionPolicy.Specific)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 versions = 1;
  {
    int byte_size = _versions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_versions(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelVersionPolicy.Specific)
  return target;
}

size_t ModelVersionPolicy_Specific::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelVersionPolicy.Specific)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 versions = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->versions_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _versions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelVersionPolicy_Specific::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelVersionPolicy_Specific::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelVersionPolicy_Specific::GetClassData() const { return &_class_data_; }

void ModelVersionPolicy_Specific::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelVersionPolicy_Specific *>(to)->MergeFrom(
      static_cast<const ModelVersionPolicy_Specific &>(from));
}


void ModelVersionPolicy_Specific::MergeFrom(const ModelVersionPolicy_Specific& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelVersionPolicy.Specific)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  versions_.MergeFrom(from.versions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelVersionPolicy_Specific::CopyFrom(const ModelVersionPolicy_Specific& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelVersionPolicy.Specific)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelVersionPolicy_Specific::IsInitialized() const {
  return true;
}

void ModelVersionPolicy_Specific::InternalSwap(ModelVersionPolicy_Specific* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  versions_.InternalSwap(&other->versions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelVersionPolicy_Specific::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[11]);
}

// ===================================================================

class ModelVersionPolicy::_Internal {
 public:
  static const ::inference::ModelVersionPolicy_Latest& latest(const ModelVersionPolicy* msg);
  static const ::inference::ModelVersionPolicy_All& all(const ModelVersionPolicy* msg);
  static const ::inference::ModelVersionPolicy_Specific& specific(const ModelVersionPolicy* msg);
};

const ::inference::ModelVersionPolicy_Latest&
ModelVersionPolicy::_Internal::latest(const ModelVersionPolicy* msg) {
  return *msg->policy_choice_.latest_;
}
const ::inference::ModelVersionPolicy_All&
ModelVersionPolicy::_Internal::all(const ModelVersionPolicy* msg) {
  return *msg->policy_choice_.all_;
}
const ::inference::ModelVersionPolicy_Specific&
ModelVersionPolicy::_Internal::specific(const ModelVersionPolicy* msg) {
  return *msg->policy_choice_.specific_;
}
void ModelVersionPolicy::set_allocated_latest(::inference::ModelVersionPolicy_Latest* latest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_policy_choice();
  if (latest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::inference::ModelVersionPolicy_Latest>::GetOwningArena(latest);
    if (message_arena != submessage_arena) {
      latest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latest, submessage_arena);
    }
    set_has_latest();
    policy_choice_.latest_ = latest;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelVersionPolicy.latest)
}
void ModelVersionPolicy::set_allocated_all(::inference::ModelVersionPolicy_All* all) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_policy_choice();
  if (all) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::inference::ModelVersionPolicy_All>::GetOwningArena(all);
    if (message_arena != submessage_arena) {
      all = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, all, submessage_arena);
    }
    set_has_all();
    policy_choice_.all_ = all;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelVersionPolicy.all)
}
void ModelVersionPolicy::set_allocated_specific(::inference::ModelVersionPolicy_Specific* specific) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_policy_choice();
  if (specific) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::inference::ModelVersionPolicy_Specific>::GetOwningArena(specific);
    if (message_arena != submessage_arena) {
      specific = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, specific, submessage_arena);
    }
    set_has_specific();
    policy_choice_.specific_ = specific;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelVersionPolicy.specific)
}
ModelVersionPolicy::ModelVersionPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelVersionPolicy)
}
ModelVersionPolicy::ModelVersionPolicy(const ModelVersionPolicy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_policy_choice();
  switch (from.policy_choice_case()) {
    case kLatest: {
      _internal_mutable_latest()->::inference::ModelVersionPolicy_Latest::MergeFrom(from._internal_latest());
      break;
    }
    case kAll: {
      _internal_mutable_all()->::inference::ModelVersionPolicy_All::MergeFrom(from._internal_all());
      break;
    }
    case kSpecific: {
      _internal_mutable_specific()->::inference::ModelVersionPolicy_Specific::MergeFrom(from._internal_specific());
      break;
    }
    case POLICY_CHOICE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelVersionPolicy)
}

inline void ModelVersionPolicy::SharedCtor() {
clear_has_policy_choice();
}

ModelVersionPolicy::~ModelVersionPolicy() {
  // @@protoc_insertion_point(destructor:inference.ModelVersionPolicy)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelVersionPolicy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_policy_choice()) {
    clear_policy_choice();
  }
}

void ModelVersionPolicy::ArenaDtor(void* object) {
  ModelVersionPolicy* _this = reinterpret_cast< ModelVersionPolicy* >(object);
  (void)_this;
}
void ModelVersionPolicy::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelVersionPolicy::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelVersionPolicy::clear_policy_choice() {
// @@protoc_insertion_point(one_of_clear_start:inference.ModelVersionPolicy)
  switch (policy_choice_case()) {
    case kLatest: {
      if (GetArenaForAllocation() == nullptr) {
        delete policy_choice_.latest_;
      }
      break;
    }
    case kAll: {
      if (GetArenaForAllocation() == nullptr) {
        delete policy_choice_.all_;
      }
      break;
    }
    case kSpecific: {
      if (GetArenaForAllocation() == nullptr) {
        delete policy_choice_.specific_;
      }
      break;
    }
    case POLICY_CHOICE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = POLICY_CHOICE_NOT_SET;
}


void ModelVersionPolicy::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelVersionPolicy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_policy_choice();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelVersionPolicy::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.ModelVersionPolicy.Latest latest = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_latest(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelVersionPolicy.All all = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_all(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelVersionPolicy.Specific specific = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_specific(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelVersionPolicy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelVersionPolicy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.ModelVersionPolicy.Latest latest = 1;
  if (_internal_has_latest()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::latest(this), target, stream);
  }

  // .inference.ModelVersionPolicy.All all = 2;
  if (_internal_has_all()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::all(this), target, stream);
  }

  // .inference.ModelVersionPolicy.Specific specific = 3;
  if (_internal_has_specific()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::specific(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelVersionPolicy)
  return target;
}

size_t ModelVersionPolicy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelVersionPolicy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (policy_choice_case()) {
    // .inference.ModelVersionPolicy.Latest latest = 1;
    case kLatest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *policy_choice_.latest_);
      break;
    }
    // .inference.ModelVersionPolicy.All all = 2;
    case kAll: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *policy_choice_.all_);
      break;
    }
    // .inference.ModelVersionPolicy.Specific specific = 3;
    case kSpecific: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *policy_choice_.specific_);
      break;
    }
    case POLICY_CHOICE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelVersionPolicy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelVersionPolicy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelVersionPolicy::GetClassData() const { return &_class_data_; }

void ModelVersionPolicy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelVersionPolicy *>(to)->MergeFrom(
      static_cast<const ModelVersionPolicy &>(from));
}


void ModelVersionPolicy::MergeFrom(const ModelVersionPolicy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelVersionPolicy)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.policy_choice_case()) {
    case kLatest: {
      _internal_mutable_latest()->::inference::ModelVersionPolicy_Latest::MergeFrom(from._internal_latest());
      break;
    }
    case kAll: {
      _internal_mutable_all()->::inference::ModelVersionPolicy_All::MergeFrom(from._internal_all());
      break;
    }
    case kSpecific: {
      _internal_mutable_specific()->::inference::ModelVersionPolicy_Specific::MergeFrom(from._internal_specific());
      break;
    }
    case POLICY_CHOICE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelVersionPolicy::CopyFrom(const ModelVersionPolicy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelVersionPolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelVersionPolicy::IsInitialized() const {
  return true;
}

void ModelVersionPolicy::InternalSwap(ModelVersionPolicy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(policy_choice_, other->policy_choice_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelVersionPolicy::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[12]);
}

// ===================================================================

class ModelOptimizationPolicy_Graph::_Internal {
 public:
};

ModelOptimizationPolicy_Graph::ModelOptimizationPolicy_Graph(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.Graph)
}
ModelOptimizationPolicy_Graph::ModelOptimizationPolicy_Graph(const ModelOptimizationPolicy_Graph& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  level_ = from.level_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.Graph)
}

inline void ModelOptimizationPolicy_Graph::SharedCtor() {
level_ = 0;
}

ModelOptimizationPolicy_Graph::~ModelOptimizationPolicy_Graph() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.Graph)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelOptimizationPolicy_Graph::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelOptimizationPolicy_Graph::ArenaDtor(void* object) {
  ModelOptimizationPolicy_Graph* _this = reinterpret_cast< ModelOptimizationPolicy_Graph* >(object);
  (void)_this;
}
void ModelOptimizationPolicy_Graph::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelOptimizationPolicy_Graph::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelOptimizationPolicy_Graph::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.Graph)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  level_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_Graph::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_Graph::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.Graph)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.Graph)
  return target;
}

size_t ModelOptimizationPolicy_Graph::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.Graph)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 level = 1;
  if (this->_internal_level() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_Graph::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelOptimizationPolicy_Graph::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_Graph::GetClassData() const { return &_class_data_; }

void ModelOptimizationPolicy_Graph::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelOptimizationPolicy_Graph *>(to)->MergeFrom(
      static_cast<const ModelOptimizationPolicy_Graph &>(from));
}


void ModelOptimizationPolicy_Graph::MergeFrom(const ModelOptimizationPolicy_Graph& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.Graph)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_level() != 0) {
    _internal_set_level(from._internal_level());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_Graph::CopyFrom(const ModelOptimizationPolicy_Graph& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.Graph)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_Graph::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_Graph::InternalSwap(ModelOptimizationPolicy_Graph* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(level_, other->level_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Graph::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[13]);
}

// ===================================================================

class ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_Internal {
 public:
};

ModelOptimizationPolicy_Cuda_GraphSpec_Shape::ModelOptimizationPolicy_Cuda_GraphSpec_Shape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  dim_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
}
ModelOptimizationPolicy_Cuda_GraphSpec_Shape::ModelOptimizationPolicy_Cuda_GraphSpec_Shape(const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      dim_(from.dim_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
}

inline void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::SharedCtor() {
}

ModelOptimizationPolicy_Cuda_GraphSpec_Shape::~ModelOptimizationPolicy_Cuda_GraphSpec_Shape() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::ArenaDtor(void* object) {
  ModelOptimizationPolicy_Cuda_GraphSpec_Shape* _this = reinterpret_cast< ModelOptimizationPolicy_Cuda_GraphSpec_Shape* >(object);
  (void)_this;
}
void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dim_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 dim = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dim(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_dim(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 dim = 1;
  {
    int byte_size = _dim_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_dim(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  return target;
}

size_t ModelOptimizationPolicy_Cuda_GraphSpec_Shape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dim = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->dim_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _dim_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelOptimizationPolicy_Cuda_GraphSpec_Shape::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_Cuda_GraphSpec_Shape::GetClassData() const { return &_class_data_; }

void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelOptimizationPolicy_Cuda_GraphSpec_Shape *>(to)->MergeFrom(
      static_cast<const ModelOptimizationPolicy_Cuda_GraphSpec_Shape &>(from));
}


void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  dim_.MergeFrom(from.dim_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::CopyFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_Cuda_GraphSpec_Shape::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::InternalSwap(ModelOptimizationPolicy_Cuda_GraphSpec_Shape* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  dim_.InternalSwap(&other->dim_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Cuda_GraphSpec_Shape::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[14]);
}

// ===================================================================

ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse() {}
ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[15]);
}

// ===================================================================

class ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_Internal {
 public:
};

ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  input_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
}
ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  input_.MergeFrom(from.input_);
  batch_size_ = from.batch_size_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
}

inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::SharedCtor() {
batch_size_ = 0;
}

ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::~ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::ArenaDtor(void* object) {
  ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* _this = reinterpret_cast< ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* >(object);
  (void)_this;
  _this->input_. ~MapField();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::ArenaDtor);
  }
}
void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_.Clear();
  batch_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 batch_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&input_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 batch_size = 1;
  if (this->_internal_batch_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_batch_size(), target);
  }

  // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
  if (!this->_internal_input().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound.InputEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_input().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_input().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >::const_iterator
          it = this->_internal_input().begin();
          it != this->_internal_input().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::Funcs::InternalSerialize(2, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >::const_iterator
          it = this->_internal_input().begin();
          it != this->_internal_input().end(); ++it) {
        target = ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::Funcs::InternalSerialize(2, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  return target;
}

size_t ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_input_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >::const_iterator
      it = this->_internal_input().begin();
      it != this->_internal_input().end(); ++it) {
    total_size += ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // int32 batch_size = 1;
  if (this->_internal_batch_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_batch_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::GetClassData() const { return &_class_data_; }

void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound *>(to)->MergeFrom(
      static_cast<const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound &>(from));
}


void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  input_.MergeFrom(from.input_);
  if (from._internal_batch_size() != 0) {
    _internal_set_batch_size(from._internal_batch_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::CopyFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::InternalSwap(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  input_.InternalSwap(&other->input_);
  swap(batch_size_, other->batch_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[16]);
}

// ===================================================================

ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse() {}
ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[17]);
}

// ===================================================================

class ModelOptimizationPolicy_Cuda_GraphSpec::_Internal {
 public:
  static const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& graph_lower_bound(const ModelOptimizationPolicy_Cuda_GraphSpec* msg);
};

const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound&
ModelOptimizationPolicy_Cuda_GraphSpec::_Internal::graph_lower_bound(const ModelOptimizationPolicy_Cuda_GraphSpec* msg) {
  return *msg->graph_lower_bound_;
}
ModelOptimizationPolicy_Cuda_GraphSpec::ModelOptimizationPolicy_Cuda_GraphSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  input_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
}
ModelOptimizationPolicy_Cuda_GraphSpec::ModelOptimizationPolicy_Cuda_GraphSpec(const ModelOptimizationPolicy_Cuda_GraphSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  input_.MergeFrom(from.input_);
  if (from._internal_has_graph_lower_bound()) {
    graph_lower_bound_ = new ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(*from.graph_lower_bound_);
  } else {
    graph_lower_bound_ = nullptr;
  }
  batch_size_ = from.batch_size_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
}

inline void ModelOptimizationPolicy_Cuda_GraphSpec::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&graph_lower_bound_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&batch_size_) -
    reinterpret_cast<char*>(&graph_lower_bound_)) + sizeof(batch_size_));
}

ModelOptimizationPolicy_Cuda_GraphSpec::~ModelOptimizationPolicy_Cuda_GraphSpec() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelOptimizationPolicy_Cuda_GraphSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete graph_lower_bound_;
}

void ModelOptimizationPolicy_Cuda_GraphSpec::ArenaDtor(void* object) {
  ModelOptimizationPolicy_Cuda_GraphSpec* _this = reinterpret_cast< ModelOptimizationPolicy_Cuda_GraphSpec* >(object);
  (void)_this;
  _this->input_. ~MapField();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ModelOptimizationPolicy_Cuda_GraphSpec::ArenaDtor);
  }
}
void ModelOptimizationPolicy_Cuda_GraphSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelOptimizationPolicy_Cuda_GraphSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_.Clear();
  if (GetArenaForAllocation() == nullptr && graph_lower_bound_ != nullptr) {
    delete graph_lower_bound_;
  }
  graph_lower_bound_ = nullptr;
  batch_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_Cuda_GraphSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 batch_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&input_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound graph_lower_bound = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_graph_lower_bound(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_Cuda_GraphSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 batch_size = 1;
  if (this->_internal_batch_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_batch_size(), target);
  }

  // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
  if (!this->_internal_input().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelOptimizationPolicy.Cuda.GraphSpec.InputEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_input().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_input().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >::const_iterator
          it = this->_internal_input().begin();
          it != this->_internal_input().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::Funcs::InternalSerialize(2, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >::const_iterator
          it = this->_internal_input().begin();
          it != this->_internal_input().end(); ++it) {
        target = ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::Funcs::InternalSerialize(2, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // .inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound graph_lower_bound = 3;
  if (this->_internal_has_graph_lower_bound()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::graph_lower_bound(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  return target;
}

size_t ModelOptimizationPolicy_Cuda_GraphSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_input_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >::const_iterator
      it = this->_internal_input().begin();
      it != this->_internal_input().end(); ++it) {
    total_size += ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound graph_lower_bound = 3;
  if (this->_internal_has_graph_lower_bound()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *graph_lower_bound_);
  }

  // int32 batch_size = 1;
  if (this->_internal_batch_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_batch_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_Cuda_GraphSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelOptimizationPolicy_Cuda_GraphSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_Cuda_GraphSpec::GetClassData() const { return &_class_data_; }

void ModelOptimizationPolicy_Cuda_GraphSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelOptimizationPolicy_Cuda_GraphSpec *>(to)->MergeFrom(
      static_cast<const ModelOptimizationPolicy_Cuda_GraphSpec &>(from));
}


void ModelOptimizationPolicy_Cuda_GraphSpec::MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  input_.MergeFrom(from.input_);
  if (from._internal_has_graph_lower_bound()) {
    _internal_mutable_graph_lower_bound()->::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::MergeFrom(from._internal_graph_lower_bound());
  }
  if (from._internal_batch_size() != 0) {
    _internal_set_batch_size(from._internal_batch_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_Cuda_GraphSpec::CopyFrom(const ModelOptimizationPolicy_Cuda_GraphSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_Cuda_GraphSpec::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_Cuda_GraphSpec::InternalSwap(ModelOptimizationPolicy_Cuda_GraphSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  input_.InternalSwap(&other->input_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelOptimizationPolicy_Cuda_GraphSpec, batch_size_)
      + sizeof(ModelOptimizationPolicy_Cuda_GraphSpec::batch_size_)
      - PROTOBUF_FIELD_OFFSET(ModelOptimizationPolicy_Cuda_GraphSpec, graph_lower_bound_)>(
          reinterpret_cast<char*>(&graph_lower_bound_),
          reinterpret_cast<char*>(&other->graph_lower_bound_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Cuda_GraphSpec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[18]);
}

// ===================================================================

class ModelOptimizationPolicy_Cuda::_Internal {
 public:
};

ModelOptimizationPolicy_Cuda::ModelOptimizationPolicy_Cuda(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  graph_spec_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.Cuda)
}
ModelOptimizationPolicy_Cuda::ModelOptimizationPolicy_Cuda(const ModelOptimizationPolicy_Cuda& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      graph_spec_(from.graph_spec_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&graphs_, &from.graphs_,
    static_cast<size_t>(reinterpret_cast<char*>(&output_copy_stream_) -
    reinterpret_cast<char*>(&graphs_)) + sizeof(output_copy_stream_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.Cuda)
}

inline void ModelOptimizationPolicy_Cuda::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&graphs_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&output_copy_stream_) -
    reinterpret_cast<char*>(&graphs_)) + sizeof(output_copy_stream_));
}

ModelOptimizationPolicy_Cuda::~ModelOptimizationPolicy_Cuda() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.Cuda)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelOptimizationPolicy_Cuda::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelOptimizationPolicy_Cuda::ArenaDtor(void* object) {
  ModelOptimizationPolicy_Cuda* _this = reinterpret_cast< ModelOptimizationPolicy_Cuda* >(object);
  (void)_this;
}
void ModelOptimizationPolicy_Cuda::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelOptimizationPolicy_Cuda::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelOptimizationPolicy_Cuda::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.Cuda)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  graph_spec_.Clear();
  ::memset(&graphs_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&output_copy_stream_) -
      reinterpret_cast<char*>(&graphs_)) + sizeof(output_copy_stream_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_Cuda::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool graphs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          graphs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool busy_wait_events = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          busy_wait_events_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelOptimizationPolicy.Cuda.GraphSpec graph_spec = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_graph_spec(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool output_copy_stream = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          output_copy_stream_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_Cuda::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.Cuda)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool graphs = 1;
  if (this->_internal_graphs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_graphs(), target);
  }

  // bool busy_wait_events = 2;
  if (this->_internal_busy_wait_events() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_busy_wait_events(), target);
  }

  // repeated .inference.ModelOptimizationPolicy.Cuda.GraphSpec graph_spec = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_graph_spec_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_graph_spec(i), target, stream);
  }

  // bool output_copy_stream = 4;
  if (this->_internal_output_copy_stream() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_output_copy_stream(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.Cuda)
  return target;
}

size_t ModelOptimizationPolicy_Cuda::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.Cuda)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelOptimizationPolicy.Cuda.GraphSpec graph_spec = 3;
  total_size += 1UL * this->_internal_graph_spec_size();
  for (const auto& msg : this->graph_spec_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bool graphs = 1;
  if (this->_internal_graphs() != 0) {
    total_size += 1 + 1;
  }

  // bool busy_wait_events = 2;
  if (this->_internal_busy_wait_events() != 0) {
    total_size += 1 + 1;
  }

  // bool output_copy_stream = 4;
  if (this->_internal_output_copy_stream() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_Cuda::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelOptimizationPolicy_Cuda::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_Cuda::GetClassData() const { return &_class_data_; }

void ModelOptimizationPolicy_Cuda::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelOptimizationPolicy_Cuda *>(to)->MergeFrom(
      static_cast<const ModelOptimizationPolicy_Cuda &>(from));
}


void ModelOptimizationPolicy_Cuda::MergeFrom(const ModelOptimizationPolicy_Cuda& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.Cuda)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  graph_spec_.MergeFrom(from.graph_spec_);
  if (from._internal_graphs() != 0) {
    _internal_set_graphs(from._internal_graphs());
  }
  if (from._internal_busy_wait_events() != 0) {
    _internal_set_busy_wait_events(from._internal_busy_wait_events());
  }
  if (from._internal_output_copy_stream() != 0) {
    _internal_set_output_copy_stream(from._internal_output_copy_stream());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_Cuda::CopyFrom(const ModelOptimizationPolicy_Cuda& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.Cuda)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_Cuda::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_Cuda::InternalSwap(ModelOptimizationPolicy_Cuda* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  graph_spec_.InternalSwap(&other->graph_spec_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelOptimizationPolicy_Cuda, output_copy_stream_)
      + sizeof(ModelOptimizationPolicy_Cuda::output_copy_stream_)
      - PROTOBUF_FIELD_OFFSET(ModelOptimizationPolicy_Cuda, graphs_)>(
          reinterpret_cast<char*>(&graphs_),
          reinterpret_cast<char*>(&other->graphs_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_Cuda::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[19]);
}

// ===================================================================

ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse() {}
ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::MergeFrom(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[20]);
}

// ===================================================================

class ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_Internal {
 public:
};

ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  parameters_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
}
ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  parameters_.MergeFrom(from.parameters_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
}

inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::~ModelOptimizationPolicy_ExecutionAccelerators_Accelerator() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::ArenaDtor(void* object) {
  ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* _this = reinterpret_cast< ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* >(object);
  (void)_this;
  _this->parameters_. ~MapField();
}
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::ArenaDtor);
  }
}
void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  parameters_.Clear();
  name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> parameters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&parameters_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // map<string, string> parameters = 2;
  if (!this->_internal_parameters().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.ParametersEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.ParametersEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_parameters().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_parameters().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_parameters().begin();
          it != this->_internal_parameters().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::Funcs::InternalSerialize(2, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_parameters().begin();
          it != this->_internal_parameters().end(); ++it) {
        target = ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::Funcs::InternalSerialize(2, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  return target;
}

size_t ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> parameters = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_parameters_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_parameters().begin();
      it != this->_internal_parameters().end(); ++it) {
    total_size += ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::GetClassData() const { return &_class_data_; }

void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelOptimizationPolicy_ExecutionAccelerators_Accelerator *>(to)->MergeFrom(
      static_cast<const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator &>(from));
}


void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::MergeFrom(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  parameters_.MergeFrom(from.parameters_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::CopyFrom(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::InternalSwap(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  parameters_.InternalSwap(&other->parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[21]);
}

// ===================================================================

class ModelOptimizationPolicy_ExecutionAccelerators::_Internal {
 public:
};

ModelOptimizationPolicy_ExecutionAccelerators::ModelOptimizationPolicy_ExecutionAccelerators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  gpu_execution_accelerator_(arena),
  cpu_execution_accelerator_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.ExecutionAccelerators)
}
ModelOptimizationPolicy_ExecutionAccelerators::ModelOptimizationPolicy_ExecutionAccelerators(const ModelOptimizationPolicy_ExecutionAccelerators& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      gpu_execution_accelerator_(from.gpu_execution_accelerator_),
      cpu_execution_accelerator_(from.cpu_execution_accelerator_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.ExecutionAccelerators)
}

inline void ModelOptimizationPolicy_ExecutionAccelerators::SharedCtor() {
}

ModelOptimizationPolicy_ExecutionAccelerators::~ModelOptimizationPolicy_ExecutionAccelerators() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelOptimizationPolicy_ExecutionAccelerators::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelOptimizationPolicy_ExecutionAccelerators::ArenaDtor(void* object) {
  ModelOptimizationPolicy_ExecutionAccelerators* _this = reinterpret_cast< ModelOptimizationPolicy_ExecutionAccelerators* >(object);
  (void)_this;
}
void ModelOptimizationPolicy_ExecutionAccelerators::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelOptimizationPolicy_ExecutionAccelerators::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelOptimizationPolicy_ExecutionAccelerators::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  gpu_execution_accelerator_.Clear();
  cpu_execution_accelerator_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_ExecutionAccelerators::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator gpu_execution_accelerator = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gpu_execution_accelerator(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator cpu_execution_accelerator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cpu_execution_accelerator(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_ExecutionAccelerators::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator gpu_execution_accelerator = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_gpu_execution_accelerator_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_gpu_execution_accelerator(i), target, stream);
  }

  // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator cpu_execution_accelerator = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cpu_execution_accelerator_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_cpu_execution_accelerator(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  return target;
}

size_t ModelOptimizationPolicy_ExecutionAccelerators::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator gpu_execution_accelerator = 1;
  total_size += 1UL * this->_internal_gpu_execution_accelerator_size();
  for (const auto& msg : this->gpu_execution_accelerator_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator cpu_execution_accelerator = 2;
  total_size += 1UL * this->_internal_cpu_execution_accelerator_size();
  for (const auto& msg : this->cpu_execution_accelerator_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_ExecutionAccelerators::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelOptimizationPolicy_ExecutionAccelerators::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_ExecutionAccelerators::GetClassData() const { return &_class_data_; }

void ModelOptimizationPolicy_ExecutionAccelerators::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelOptimizationPolicy_ExecutionAccelerators *>(to)->MergeFrom(
      static_cast<const ModelOptimizationPolicy_ExecutionAccelerators &>(from));
}


void ModelOptimizationPolicy_ExecutionAccelerators::MergeFrom(const ModelOptimizationPolicy_ExecutionAccelerators& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  gpu_execution_accelerator_.MergeFrom(from.gpu_execution_accelerator_);
  cpu_execution_accelerator_.MergeFrom(from.cpu_execution_accelerator_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_ExecutionAccelerators::CopyFrom(const ModelOptimizationPolicy_ExecutionAccelerators& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.ExecutionAccelerators)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_ExecutionAccelerators::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_ExecutionAccelerators::InternalSwap(ModelOptimizationPolicy_ExecutionAccelerators* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  gpu_execution_accelerator_.InternalSwap(&other->gpu_execution_accelerator_);
  cpu_execution_accelerator_.InternalSwap(&other->cpu_execution_accelerator_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_ExecutionAccelerators::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[22]);
}

// ===================================================================

class ModelOptimizationPolicy_PinnedMemoryBuffer::_Internal {
 public:
};

ModelOptimizationPolicy_PinnedMemoryBuffer::ModelOptimizationPolicy_PinnedMemoryBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
}
ModelOptimizationPolicy_PinnedMemoryBuffer::ModelOptimizationPolicy_PinnedMemoryBuffer(const ModelOptimizationPolicy_PinnedMemoryBuffer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  enable_ = from.enable_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
}

inline void ModelOptimizationPolicy_PinnedMemoryBuffer::SharedCtor() {
enable_ = false;
}

ModelOptimizationPolicy_PinnedMemoryBuffer::~ModelOptimizationPolicy_PinnedMemoryBuffer() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelOptimizationPolicy_PinnedMemoryBuffer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelOptimizationPolicy_PinnedMemoryBuffer::ArenaDtor(void* object) {
  ModelOptimizationPolicy_PinnedMemoryBuffer* _this = reinterpret_cast< ModelOptimizationPolicy_PinnedMemoryBuffer* >(object);
  (void)_this;
}
void ModelOptimizationPolicy_PinnedMemoryBuffer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelOptimizationPolicy_PinnedMemoryBuffer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelOptimizationPolicy_PinnedMemoryBuffer::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  enable_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy_PinnedMemoryBuffer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy_PinnedMemoryBuffer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enable = 1;
  if (this->_internal_enable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_enable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  return target;
}

size_t ModelOptimizationPolicy_PinnedMemoryBuffer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool enable = 1;
  if (this->_internal_enable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy_PinnedMemoryBuffer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelOptimizationPolicy_PinnedMemoryBuffer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy_PinnedMemoryBuffer::GetClassData() const { return &_class_data_; }

void ModelOptimizationPolicy_PinnedMemoryBuffer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelOptimizationPolicy_PinnedMemoryBuffer *>(to)->MergeFrom(
      static_cast<const ModelOptimizationPolicy_PinnedMemoryBuffer &>(from));
}


void ModelOptimizationPolicy_PinnedMemoryBuffer::MergeFrom(const ModelOptimizationPolicy_PinnedMemoryBuffer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_enable() != 0) {
    _internal_set_enable(from._internal_enable());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy_PinnedMemoryBuffer::CopyFrom(const ModelOptimizationPolicy_PinnedMemoryBuffer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy_PinnedMemoryBuffer::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy_PinnedMemoryBuffer::InternalSwap(ModelOptimizationPolicy_PinnedMemoryBuffer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(enable_, other->enable_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy_PinnedMemoryBuffer::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[23]);
}

// ===================================================================

class ModelOptimizationPolicy::_Internal {
 public:
  static const ::inference::ModelOptimizationPolicy_Graph& graph(const ModelOptimizationPolicy* msg);
  static const ::inference::ModelOptimizationPolicy_Cuda& cuda(const ModelOptimizationPolicy* msg);
  static const ::inference::ModelOptimizationPolicy_ExecutionAccelerators& execution_accelerators(const ModelOptimizationPolicy* msg);
  static const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& input_pinned_memory(const ModelOptimizationPolicy* msg);
  static const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& output_pinned_memory(const ModelOptimizationPolicy* msg);
};

const ::inference::ModelOptimizationPolicy_Graph&
ModelOptimizationPolicy::_Internal::graph(const ModelOptimizationPolicy* msg) {
  return *msg->graph_;
}
const ::inference::ModelOptimizationPolicy_Cuda&
ModelOptimizationPolicy::_Internal::cuda(const ModelOptimizationPolicy* msg) {
  return *msg->cuda_;
}
const ::inference::ModelOptimizationPolicy_ExecutionAccelerators&
ModelOptimizationPolicy::_Internal::execution_accelerators(const ModelOptimizationPolicy* msg) {
  return *msg->execution_accelerators_;
}
const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer&
ModelOptimizationPolicy::_Internal::input_pinned_memory(const ModelOptimizationPolicy* msg) {
  return *msg->input_pinned_memory_;
}
const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer&
ModelOptimizationPolicy::_Internal::output_pinned_memory(const ModelOptimizationPolicy* msg) {
  return *msg->output_pinned_memory_;
}
ModelOptimizationPolicy::ModelOptimizationPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOptimizationPolicy)
}
ModelOptimizationPolicy::ModelOptimizationPolicy(const ModelOptimizationPolicy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_graph()) {
    graph_ = new ::inference::ModelOptimizationPolicy_Graph(*from.graph_);
  } else {
    graph_ = nullptr;
  }
  if (from._internal_has_cuda()) {
    cuda_ = new ::inference::ModelOptimizationPolicy_Cuda(*from.cuda_);
  } else {
    cuda_ = nullptr;
  }
  if (from._internal_has_execution_accelerators()) {
    execution_accelerators_ = new ::inference::ModelOptimizationPolicy_ExecutionAccelerators(*from.execution_accelerators_);
  } else {
    execution_accelerators_ = nullptr;
  }
  if (from._internal_has_input_pinned_memory()) {
    input_pinned_memory_ = new ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer(*from.input_pinned_memory_);
  } else {
    input_pinned_memory_ = nullptr;
  }
  if (from._internal_has_output_pinned_memory()) {
    output_pinned_memory_ = new ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer(*from.output_pinned_memory_);
  } else {
    output_pinned_memory_ = nullptr;
  }
  ::memcpy(&priority_, &from.priority_,
    static_cast<size_t>(reinterpret_cast<char*>(&eager_batching_) -
    reinterpret_cast<char*>(&priority_)) + sizeof(eager_batching_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelOptimizationPolicy)
}

inline void ModelOptimizationPolicy::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&graph_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&eager_batching_) -
    reinterpret_cast<char*>(&graph_)) + sizeof(eager_batching_));
}

ModelOptimizationPolicy::~ModelOptimizationPolicy() {
  // @@protoc_insertion_point(destructor:inference.ModelOptimizationPolicy)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelOptimizationPolicy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete graph_;
  if (this != internal_default_instance()) delete cuda_;
  if (this != internal_default_instance()) delete execution_accelerators_;
  if (this != internal_default_instance()) delete input_pinned_memory_;
  if (this != internal_default_instance()) delete output_pinned_memory_;
}

void ModelOptimizationPolicy::ArenaDtor(void* object) {
  ModelOptimizationPolicy* _this = reinterpret_cast< ModelOptimizationPolicy* >(object);
  (void)_this;
}
void ModelOptimizationPolicy::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelOptimizationPolicy::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelOptimizationPolicy::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOptimizationPolicy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && graph_ != nullptr) {
    delete graph_;
  }
  graph_ = nullptr;
  if (GetArenaForAllocation() == nullptr && cuda_ != nullptr) {
    delete cuda_;
  }
  cuda_ = nullptr;
  if (GetArenaForAllocation() == nullptr && execution_accelerators_ != nullptr) {
    delete execution_accelerators_;
  }
  execution_accelerators_ = nullptr;
  if (GetArenaForAllocation() == nullptr && input_pinned_memory_ != nullptr) {
    delete input_pinned_memory_;
  }
  input_pinned_memory_ = nullptr;
  if (GetArenaForAllocation() == nullptr && output_pinned_memory_ != nullptr) {
    delete output_pinned_memory_;
  }
  output_pinned_memory_ = nullptr;
  ::memset(&priority_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&eager_batching_) -
      reinterpret_cast<char*>(&priority_)) + sizeof(eager_batching_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOptimizationPolicy::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.ModelOptimizationPolicy.Graph graph = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_graph(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy.ModelPriority priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_priority(static_cast<::inference::ModelOptimizationPolicy_ModelPriority>(val));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy.Cuda cuda = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cuda(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy.ExecutionAccelerators execution_accelerators = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_execution_accelerators(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer input_pinned_memory = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_input_pinned_memory(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer output_pinned_memory = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_output_pinned_memory(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 gather_kernel_buffer_threshold = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          gather_kernel_buffer_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool eager_batching = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          eager_batching_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOptimizationPolicy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOptimizationPolicy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.ModelOptimizationPolicy.Graph graph = 1;
  if (this->_internal_has_graph()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::graph(this), target, stream);
  }

  // .inference.ModelOptimizationPolicy.ModelPriority priority = 2;
  if (this->_internal_priority() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_priority(), target);
  }

  // .inference.ModelOptimizationPolicy.Cuda cuda = 3;
  if (this->_internal_has_cuda()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::cuda(this), target, stream);
  }

  // .inference.ModelOptimizationPolicy.ExecutionAccelerators execution_accelerators = 4;
  if (this->_internal_has_execution_accelerators()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::execution_accelerators(this), target, stream);
  }

  // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer input_pinned_memory = 5;
  if (this->_internal_has_input_pinned_memory()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::input_pinned_memory(this), target, stream);
  }

  // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer output_pinned_memory = 6;
  if (this->_internal_has_output_pinned_memory()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::output_pinned_memory(this), target, stream);
  }

  // uint32 gather_kernel_buffer_threshold = 7;
  if (this->_internal_gather_kernel_buffer_threshold() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_gather_kernel_buffer_threshold(), target);
  }

  // bool eager_batching = 8;
  if (this->_internal_eager_batching() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_eager_batching(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOptimizationPolicy)
  return target;
}

size_t ModelOptimizationPolicy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOptimizationPolicy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .inference.ModelOptimizationPolicy.Graph graph = 1;
  if (this->_internal_has_graph()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *graph_);
  }

  // .inference.ModelOptimizationPolicy.Cuda cuda = 3;
  if (this->_internal_has_cuda()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cuda_);
  }

  // .inference.ModelOptimizationPolicy.ExecutionAccelerators execution_accelerators = 4;
  if (this->_internal_has_execution_accelerators()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *execution_accelerators_);
  }

  // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer input_pinned_memory = 5;
  if (this->_internal_has_input_pinned_memory()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *input_pinned_memory_);
  }

  // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer output_pinned_memory = 6;
  if (this->_internal_has_output_pinned_memory()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *output_pinned_memory_);
  }

  // .inference.ModelOptimizationPolicy.ModelPriority priority = 2;
  if (this->_internal_priority() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_priority());
  }

  // uint32 gather_kernel_buffer_threshold = 7;
  if (this->_internal_gather_kernel_buffer_threshold() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gather_kernel_buffer_threshold());
  }

  // bool eager_batching = 8;
  if (this->_internal_eager_batching() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOptimizationPolicy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelOptimizationPolicy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOptimizationPolicy::GetClassData() const { return &_class_data_; }

void ModelOptimizationPolicy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelOptimizationPolicy *>(to)->MergeFrom(
      static_cast<const ModelOptimizationPolicy &>(from));
}


void ModelOptimizationPolicy::MergeFrom(const ModelOptimizationPolicy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOptimizationPolicy)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_graph()) {
    _internal_mutable_graph()->::inference::ModelOptimizationPolicy_Graph::MergeFrom(from._internal_graph());
  }
  if (from._internal_has_cuda()) {
    _internal_mutable_cuda()->::inference::ModelOptimizationPolicy_Cuda::MergeFrom(from._internal_cuda());
  }
  if (from._internal_has_execution_accelerators()) {
    _internal_mutable_execution_accelerators()->::inference::ModelOptimizationPolicy_ExecutionAccelerators::MergeFrom(from._internal_execution_accelerators());
  }
  if (from._internal_has_input_pinned_memory()) {
    _internal_mutable_input_pinned_memory()->::inference::ModelOptimizationPolicy_PinnedMemoryBuffer::MergeFrom(from._internal_input_pinned_memory());
  }
  if (from._internal_has_output_pinned_memory()) {
    _internal_mutable_output_pinned_memory()->::inference::ModelOptimizationPolicy_PinnedMemoryBuffer::MergeFrom(from._internal_output_pinned_memory());
  }
  if (from._internal_priority() != 0) {
    _internal_set_priority(from._internal_priority());
  }
  if (from._internal_gather_kernel_buffer_threshold() != 0) {
    _internal_set_gather_kernel_buffer_threshold(from._internal_gather_kernel_buffer_threshold());
  }
  if (from._internal_eager_batching() != 0) {
    _internal_set_eager_batching(from._internal_eager_batching());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOptimizationPolicy::CopyFrom(const ModelOptimizationPolicy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOptimizationPolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOptimizationPolicy::IsInitialized() const {
  return true;
}

void ModelOptimizationPolicy::InternalSwap(ModelOptimizationPolicy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelOptimizationPolicy, eager_batching_)
      + sizeof(ModelOptimizationPolicy::eager_batching_)
      - PROTOBUF_FIELD_OFFSET(ModelOptimizationPolicy, graph_)>(
          reinterpret_cast<char*>(&graph_),
          reinterpret_cast<char*>(&other->graph_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOptimizationPolicy::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[24]);
}

// ===================================================================

class ModelQueuePolicy::_Internal {
 public:
};

ModelQueuePolicy::ModelQueuePolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelQueuePolicy)
}
ModelQueuePolicy::ModelQueuePolicy(const ModelQueuePolicy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&default_timeout_microseconds_, &from.default_timeout_microseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_queue_size_) -
    reinterpret_cast<char*>(&default_timeout_microseconds_)) + sizeof(max_queue_size_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelQueuePolicy)
}

inline void ModelQueuePolicy::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&default_timeout_microseconds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_queue_size_) -
    reinterpret_cast<char*>(&default_timeout_microseconds_)) + sizeof(max_queue_size_));
}

ModelQueuePolicy::~ModelQueuePolicy() {
  // @@protoc_insertion_point(destructor:inference.ModelQueuePolicy)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelQueuePolicy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelQueuePolicy::ArenaDtor(void* object) {
  ModelQueuePolicy* _this = reinterpret_cast< ModelQueuePolicy* >(object);
  (void)_this;
}
void ModelQueuePolicy::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelQueuePolicy::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelQueuePolicy::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelQueuePolicy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&default_timeout_microseconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_queue_size_) -
      reinterpret_cast<char*>(&default_timeout_microseconds_)) + sizeof(max_queue_size_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelQueuePolicy::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.ModelQueuePolicy.TimeoutAction timeout_action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_timeout_action(static_cast<::inference::ModelQueuePolicy_TimeoutAction>(val));
        } else
          goto handle_unusual;
        continue;
      // uint64 default_timeout_microseconds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          default_timeout_microseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_timeout_override = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          allow_timeout_override_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_queue_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          max_queue_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelQueuePolicy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelQueuePolicy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.ModelQueuePolicy.TimeoutAction timeout_action = 1;
  if (this->_internal_timeout_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_timeout_action(), target);
  }

  // uint64 default_timeout_microseconds = 2;
  if (this->_internal_default_timeout_microseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_default_timeout_microseconds(), target);
  }

  // bool allow_timeout_override = 3;
  if (this->_internal_allow_timeout_override() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_timeout_override(), target);
  }

  // uint32 max_queue_size = 4;
  if (this->_internal_max_queue_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_max_queue_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelQueuePolicy)
  return target;
}

size_t ModelQueuePolicy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelQueuePolicy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 default_timeout_microseconds = 2;
  if (this->_internal_default_timeout_microseconds() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_default_timeout_microseconds());
  }

  // .inference.ModelQueuePolicy.TimeoutAction timeout_action = 1;
  if (this->_internal_timeout_action() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_timeout_action());
  }

  // bool allow_timeout_override = 3;
  if (this->_internal_allow_timeout_override() != 0) {
    total_size += 1 + 1;
  }

  // uint32 max_queue_size = 4;
  if (this->_internal_max_queue_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_max_queue_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelQueuePolicy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelQueuePolicy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelQueuePolicy::GetClassData() const { return &_class_data_; }

void ModelQueuePolicy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelQueuePolicy *>(to)->MergeFrom(
      static_cast<const ModelQueuePolicy &>(from));
}


void ModelQueuePolicy::MergeFrom(const ModelQueuePolicy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelQueuePolicy)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_default_timeout_microseconds() != 0) {
    _internal_set_default_timeout_microseconds(from._internal_default_timeout_microseconds());
  }
  if (from._internal_timeout_action() != 0) {
    _internal_set_timeout_action(from._internal_timeout_action());
  }
  if (from._internal_allow_timeout_override() != 0) {
    _internal_set_allow_timeout_override(from._internal_allow_timeout_override());
  }
  if (from._internal_max_queue_size() != 0) {
    _internal_set_max_queue_size(from._internal_max_queue_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelQueuePolicy::CopyFrom(const ModelQueuePolicy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelQueuePolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelQueuePolicy::IsInitialized() const {
  return true;
}

void ModelQueuePolicy::InternalSwap(ModelQueuePolicy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelQueuePolicy, max_queue_size_)
      + sizeof(ModelQueuePolicy::max_queue_size_)
      - PROTOBUF_FIELD_OFFSET(ModelQueuePolicy, default_timeout_microseconds_)>(
          reinterpret_cast<char*>(&default_timeout_microseconds_),
          reinterpret_cast<char*>(&other->default_timeout_microseconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelQueuePolicy::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[25]);
}

// ===================================================================

ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse() {}
ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::MergeFrom(const ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[26]);
}

// ===================================================================

class ModelDynamicBatching::_Internal {
 public:
  static const ::inference::ModelQueuePolicy& default_queue_policy(const ModelDynamicBatching* msg);
};

const ::inference::ModelQueuePolicy&
ModelDynamicBatching::_Internal::default_queue_policy(const ModelDynamicBatching* msg) {
  return *msg->default_queue_policy_;
}
ModelDynamicBatching::ModelDynamicBatching(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  preferred_batch_size_(arena),
  priority_queue_policy_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelDynamicBatching)
}
ModelDynamicBatching::ModelDynamicBatching(const ModelDynamicBatching& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      preferred_batch_size_(from.preferred_batch_size_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  priority_queue_policy_.MergeFrom(from.priority_queue_policy_);
  if (from._internal_has_default_queue_policy()) {
    default_queue_policy_ = new ::inference::ModelQueuePolicy(*from.default_queue_policy_);
  } else {
    default_queue_policy_ = nullptr;
  }
  ::memcpy(&max_queue_delay_microseconds_, &from.max_queue_delay_microseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&preserve_ordering_) -
    reinterpret_cast<char*>(&max_queue_delay_microseconds_)) + sizeof(preserve_ordering_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelDynamicBatching)
}

inline void ModelDynamicBatching::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&default_queue_policy_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&preserve_ordering_) -
    reinterpret_cast<char*>(&default_queue_policy_)) + sizeof(preserve_ordering_));
}

ModelDynamicBatching::~ModelDynamicBatching() {
  // @@protoc_insertion_point(destructor:inference.ModelDynamicBatching)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelDynamicBatching::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete default_queue_policy_;
}

void ModelDynamicBatching::ArenaDtor(void* object) {
  ModelDynamicBatching* _this = reinterpret_cast< ModelDynamicBatching* >(object);
  (void)_this;
  _this->priority_queue_policy_. ~MapField();
}
inline void ModelDynamicBatching::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ModelDynamicBatching::ArenaDtor);
  }
}
void ModelDynamicBatching::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelDynamicBatching::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelDynamicBatching)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  preferred_batch_size_.Clear();
  priority_queue_policy_.Clear();
  if (GetArenaForAllocation() == nullptr && default_queue_policy_ != nullptr) {
    delete default_queue_policy_;
  }
  default_queue_policy_ = nullptr;
  ::memset(&max_queue_delay_microseconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&preserve_ordering_) -
      reinterpret_cast<char*>(&max_queue_delay_microseconds_)) + sizeof(preserve_ordering_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelDynamicBatching::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 preferred_batch_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_preferred_batch_size(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 max_queue_delay_microseconds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          max_queue_delay_microseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool preserve_ordering = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          preserve_ordering_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 priority_levels = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          priority_levels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 default_priority_level = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          default_priority_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelQueuePolicy default_queue_policy = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_queue_policy(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<uint64, .inference.ModelQueuePolicy> priority_queue_policy = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&priority_queue_policy_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelDynamicBatching::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelDynamicBatching)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 preferred_batch_size = 1;
  {
    int byte_size = _preferred_batch_size_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_preferred_batch_size(), byte_size, target);
    }
  }

  // uint64 max_queue_delay_microseconds = 2;
  if (this->_internal_max_queue_delay_microseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_max_queue_delay_microseconds(), target);
  }

  // bool preserve_ordering = 3;
  if (this->_internal_preserve_ordering() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_preserve_ordering(), target);
  }

  // uint64 priority_levels = 4;
  if (this->_internal_priority_levels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_priority_levels(), target);
  }

  // uint64 default_priority_level = 5;
  if (this->_internal_default_priority_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_default_priority_level(), target);
  }

  // .inference.ModelQueuePolicy default_queue_policy = 6;
  if (this->_internal_has_default_queue_policy()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::default_queue_policy(this), target, stream);
  }

  // map<uint64, .inference.ModelQueuePolicy> priority_queue_policy = 7;
  if (!this->_internal_priority_queue_policy().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >::const_pointer
        ConstPtr;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::SortItem< uint64_t, ConstPtr > SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByFirstField<SortItem> Less;

    if (stream->IsSerializationDeterministic() &&
        this->_internal_priority_queue_policy().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_priority_queue_policy().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >::const_iterator
          it = this->_internal_priority_queue_policy().begin();
          it != this->_internal_priority_queue_policy().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::Funcs::InternalSerialize(7, items[static_cast<ptrdiff_t>(i)].second->first, items[static_cast<ptrdiff_t>(i)].second->second, target, stream);
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >::const_iterator
          it = this->_internal_priority_queue_policy().begin();
          it != this->_internal_priority_queue_policy().end(); ++it) {
        target = ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::Funcs::InternalSerialize(7, it->first, it->second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelDynamicBatching)
  return target;
}

size_t ModelDynamicBatching::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelDynamicBatching)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 preferred_batch_size = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->preferred_batch_size_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _preferred_batch_size_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // map<uint64, .inference.ModelQueuePolicy> priority_queue_policy = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_priority_queue_policy_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inference::ModelQueuePolicy >::const_iterator
      it = this->_internal_priority_queue_policy().begin();
      it != this->_internal_priority_queue_policy().end(); ++it) {
    total_size += ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .inference.ModelQueuePolicy default_queue_policy = 6;
  if (this->_internal_has_default_queue_policy()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *default_queue_policy_);
  }

  // uint64 max_queue_delay_microseconds = 2;
  if (this->_internal_max_queue_delay_microseconds() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_max_queue_delay_microseconds());
  }

  // uint64 priority_levels = 4;
  if (this->_internal_priority_levels() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_priority_levels());
  }

  // uint64 default_priority_level = 5;
  if (this->_internal_default_priority_level() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_default_priority_level());
  }

  // bool preserve_ordering = 3;
  if (this->_internal_preserve_ordering() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelDynamicBatching::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelDynamicBatching::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelDynamicBatching::GetClassData() const { return &_class_data_; }

void ModelDynamicBatching::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelDynamicBatching *>(to)->MergeFrom(
      static_cast<const ModelDynamicBatching &>(from));
}


void ModelDynamicBatching::MergeFrom(const ModelDynamicBatching& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelDynamicBatching)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  preferred_batch_size_.MergeFrom(from.preferred_batch_size_);
  priority_queue_policy_.MergeFrom(from.priority_queue_policy_);
  if (from._internal_has_default_queue_policy()) {
    _internal_mutable_default_queue_policy()->::inference::ModelQueuePolicy::MergeFrom(from._internal_default_queue_policy());
  }
  if (from._internal_max_queue_delay_microseconds() != 0) {
    _internal_set_max_queue_delay_microseconds(from._internal_max_queue_delay_microseconds());
  }
  if (from._internal_priority_levels() != 0) {
    _internal_set_priority_levels(from._internal_priority_levels());
  }
  if (from._internal_default_priority_level() != 0) {
    _internal_set_default_priority_level(from._internal_default_priority_level());
  }
  if (from._internal_preserve_ordering() != 0) {
    _internal_set_preserve_ordering(from._internal_preserve_ordering());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelDynamicBatching::CopyFrom(const ModelDynamicBatching& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelDynamicBatching)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelDynamicBatching::IsInitialized() const {
  return true;
}

void ModelDynamicBatching::InternalSwap(ModelDynamicBatching* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  preferred_batch_size_.InternalSwap(&other->preferred_batch_size_);
  priority_queue_policy_.InternalSwap(&other->priority_queue_policy_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelDynamicBatching, preserve_ordering_)
      + sizeof(ModelDynamicBatching::preserve_ordering_)
      - PROTOBUF_FIELD_OFFSET(ModelDynamicBatching, default_queue_policy_)>(
          reinterpret_cast<char*>(&default_queue_policy_),
          reinterpret_cast<char*>(&other->default_queue_policy_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelDynamicBatching::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[27]);
}

// ===================================================================

class ModelSequenceBatching_Control::_Internal {
 public:
};

ModelSequenceBatching_Control::ModelSequenceBatching_Control(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  int32_false_true_(arena),
  fp32_false_true_(arena),
  bool_false_true_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching.Control)
}
ModelSequenceBatching_Control::ModelSequenceBatching_Control(const ModelSequenceBatching_Control& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      int32_false_true_(from.int32_false_true_),
      fp32_false_true_(from.fp32_false_true_),
      bool_false_true_(from.bool_false_true_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&kind_, &from.kind_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_type_) -
    reinterpret_cast<char*>(&kind_)) + sizeof(data_type_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching.Control)
}

inline void ModelSequenceBatching_Control::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&kind_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&data_type_) -
    reinterpret_cast<char*>(&kind_)) + sizeof(data_type_));
}

ModelSequenceBatching_Control::~ModelSequenceBatching_Control() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching.Control)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelSequenceBatching_Control::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelSequenceBatching_Control::ArenaDtor(void* object) {
  ModelSequenceBatching_Control* _this = reinterpret_cast< ModelSequenceBatching_Control* >(object);
  (void)_this;
}
void ModelSequenceBatching_Control::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelSequenceBatching_Control::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelSequenceBatching_Control::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching.Control)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int32_false_true_.Clear();
  fp32_false_true_.Clear();
  bool_false_true_.Clear();
  ::memset(&kind_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&data_type_) -
      reinterpret_cast<char*>(&kind_)) + sizeof(data_type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching_Control::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.ModelSequenceBatching.Control.Kind kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_kind(static_cast<::inference::ModelSequenceBatching_Control_Kind>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 int32_false_true = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_int32_false_true(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_int32_false_true(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float fp32_false_true = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_fp32_false_true(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 29) {
          _internal_add_fp32_false_true(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .inference.DataType data_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated bool bool_false_true = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_bool_false_true(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_bool_false_true(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching_Control::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching.Control)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.ModelSequenceBatching.Control.Kind kind = 1;
  if (this->_internal_kind() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // repeated int32 int32_false_true = 2;
  {
    int byte_size = _int32_false_true_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_int32_false_true(), byte_size, target);
    }
  }

  // repeated float fp32_false_true = 3;
  if (this->_internal_fp32_false_true_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_fp32_false_true(), target);
  }

  // .inference.DataType data_type = 4;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_data_type(), target);
  }

  // repeated bool bool_false_true = 5;
  if (this->_internal_bool_false_true_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_bool_false_true(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching.Control)
  return target;
}

size_t ModelSequenceBatching_Control::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching.Control)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 int32_false_true = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->int32_false_true_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _int32_false_true_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated float fp32_false_true = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_fp32_false_true_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated bool bool_false_true = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_bool_false_true_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // .inference.ModelSequenceBatching.Control.Kind kind = 1;
  if (this->_internal_kind() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_kind());
  }

  // .inference.DataType data_type = 4;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching_Control::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelSequenceBatching_Control::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching_Control::GetClassData() const { return &_class_data_; }

void ModelSequenceBatching_Control::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelSequenceBatching_Control *>(to)->MergeFrom(
      static_cast<const ModelSequenceBatching_Control &>(from));
}


void ModelSequenceBatching_Control::MergeFrom(const ModelSequenceBatching_Control& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching.Control)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  int32_false_true_.MergeFrom(from.int32_false_true_);
  fp32_false_true_.MergeFrom(from.fp32_false_true_);
  bool_false_true_.MergeFrom(from.bool_false_true_);
  if (from._internal_kind() != 0) {
    _internal_set_kind(from._internal_kind());
  }
  if (from._internal_data_type() != 0) {
    _internal_set_data_type(from._internal_data_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching_Control::CopyFrom(const ModelSequenceBatching_Control& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching.Control)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching_Control::IsInitialized() const {
  return true;
}

void ModelSequenceBatching_Control::InternalSwap(ModelSequenceBatching_Control* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  int32_false_true_.InternalSwap(&other->int32_false_true_);
  fp32_false_true_.InternalSwap(&other->fp32_false_true_);
  bool_false_true_.InternalSwap(&other->bool_false_true_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_Control, data_type_)
      + sizeof(ModelSequenceBatching_Control::data_type_)
      - PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_Control, kind_)>(
          reinterpret_cast<char*>(&kind_),
          reinterpret_cast<char*>(&other->kind_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching_Control::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[28]);
}

// ===================================================================

class ModelSequenceBatching_ControlInput::_Internal {
 public:
};

ModelSequenceBatching_ControlInput::ModelSequenceBatching_ControlInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  control_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching.ControlInput)
}
ModelSequenceBatching_ControlInput::ModelSequenceBatching_ControlInput(const ModelSequenceBatching_ControlInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      control_(from.control_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching.ControlInput)
}

inline void ModelSequenceBatching_ControlInput::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelSequenceBatching_ControlInput::~ModelSequenceBatching_ControlInput() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching.ControlInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelSequenceBatching_ControlInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ModelSequenceBatching_ControlInput::ArenaDtor(void* object) {
  ModelSequenceBatching_ControlInput* _this = reinterpret_cast< ModelSequenceBatching_ControlInput* >(object);
  (void)_this;
}
void ModelSequenceBatching_ControlInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelSequenceBatching_ControlInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelSequenceBatching_ControlInput::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching.ControlInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  control_.Clear();
  name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching_ControlInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelSequenceBatching.ControlInput.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelSequenceBatching.Control control = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_control(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching_ControlInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching.ControlInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelSequenceBatching.ControlInput.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .inference.ModelSequenceBatching.Control control = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_control_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_control(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching.ControlInput)
  return target;
}

size_t ModelSequenceBatching_ControlInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching.ControlInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelSequenceBatching.Control control = 2;
  total_size += 1UL * this->_internal_control_size();
  for (const auto& msg : this->control_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching_ControlInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelSequenceBatching_ControlInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching_ControlInput::GetClassData() const { return &_class_data_; }

void ModelSequenceBatching_ControlInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelSequenceBatching_ControlInput *>(to)->MergeFrom(
      static_cast<const ModelSequenceBatching_ControlInput &>(from));
}


void ModelSequenceBatching_ControlInput::MergeFrom(const ModelSequenceBatching_ControlInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching.ControlInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  control_.MergeFrom(from.control_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching_ControlInput::CopyFrom(const ModelSequenceBatching_ControlInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching.ControlInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching_ControlInput::IsInitialized() const {
  return true;
}

void ModelSequenceBatching_ControlInput::InternalSwap(ModelSequenceBatching_ControlInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  control_.InternalSwap(&other->control_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching_ControlInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[29]);
}

// ===================================================================

class ModelSequenceBatching_InitialState::_Internal {
 public:
};

ModelSequenceBatching_InitialState::ModelSequenceBatching_InitialState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  dims_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching.InitialState)
}
ModelSequenceBatching_InitialState::ModelSequenceBatching_InitialState(const ModelSequenceBatching_InitialState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      dims_(from.dims_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  data_type_ = from.data_type_;
  clear_has_state_data();
  switch (from.state_data_case()) {
    case kZeroData: {
      _internal_set_zero_data(from._internal_zero_data());
      break;
    }
    case kDataFile: {
      _internal_set_data_file(from._internal_data_file());
      break;
    }
    case STATE_DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching.InitialState)
}

inline void ModelSequenceBatching_InitialState::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
data_type_ = 0;
clear_has_state_data();
}

ModelSequenceBatching_InitialState::~ModelSequenceBatching_InitialState() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching.InitialState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelSequenceBatching_InitialState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_state_data()) {
    clear_state_data();
  }
}

void ModelSequenceBatching_InitialState::ArenaDtor(void* object) {
  ModelSequenceBatching_InitialState* _this = reinterpret_cast< ModelSequenceBatching_InitialState* >(object);
  (void)_this;
}
void ModelSequenceBatching_InitialState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelSequenceBatching_InitialState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelSequenceBatching_InitialState::clear_state_data() {
// @@protoc_insertion_point(one_of_clear_start:inference.ModelSequenceBatching.InitialState)
  switch (state_data_case()) {
    case kZeroData: {
      // No need to clear
      break;
    }
    case kDataFile: {
      state_data_.data_file_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
      break;
    }
    case STATE_DATA_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = STATE_DATA_NOT_SET;
}


void ModelSequenceBatching_InitialState::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching.InitialState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  name_.ClearToEmpty();
  data_type_ = 0;
  clear_state_data();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching_InitialState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.DataType data_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 dims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool zero_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_zero_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string data_file = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_data_file();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelSequenceBatching.InitialState.data_file"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelSequenceBatching.InitialState.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching_InitialState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching.InitialState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.DataType data_type = 1;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_data_type(), target);
  }

  // repeated int64 dims = 2;
  {
    int byte_size = _dims_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_dims(), byte_size, target);
    }
  }

  // bool zero_data = 3;
  if (_internal_has_zero_data()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_zero_data(), target);
  }

  // string data_file = 4;
  if (_internal_has_data_file()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_data_file().data(), static_cast<int>(this->_internal_data_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelSequenceBatching.InitialState.data_file");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_data_file(), target);
  }

  // string name = 5;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelSequenceBatching.InitialState.name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching.InitialState)
  return target;
}

size_t ModelSequenceBatching_InitialState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching.InitialState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->dims_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _dims_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string name = 5;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .inference.DataType data_type = 1;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  switch (state_data_case()) {
    // bool zero_data = 3;
    case kZeroData: {
      total_size += 1 + 1;
      break;
    }
    // string data_file = 4;
    case kDataFile: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_data_file());
      break;
    }
    case STATE_DATA_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching_InitialState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelSequenceBatching_InitialState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching_InitialState::GetClassData() const { return &_class_data_; }

void ModelSequenceBatching_InitialState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelSequenceBatching_InitialState *>(to)->MergeFrom(
      static_cast<const ModelSequenceBatching_InitialState &>(from));
}


void ModelSequenceBatching_InitialState::MergeFrom(const ModelSequenceBatching_InitialState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching.InitialState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_data_type() != 0) {
    _internal_set_data_type(from._internal_data_type());
  }
  switch (from.state_data_case()) {
    case kZeroData: {
      _internal_set_zero_data(from._internal_zero_data());
      break;
    }
    case kDataFile: {
      _internal_set_data_file(from._internal_data_file());
      break;
    }
    case STATE_DATA_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching_InitialState::CopyFrom(const ModelSequenceBatching_InitialState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching.InitialState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching_InitialState::IsInitialized() const {
  return true;
}

void ModelSequenceBatching_InitialState::InternalSwap(ModelSequenceBatching_InitialState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  dims_.InternalSwap(&other->dims_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(data_type_, other->data_type_);
  swap(state_data_, other->state_data_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching_InitialState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[30]);
}

// ===================================================================

class ModelSequenceBatching_State::_Internal {
 public:
};

ModelSequenceBatching_State::ModelSequenceBatching_State(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  dims_(arena),
  initial_state_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching.State)
}
ModelSequenceBatching_State::ModelSequenceBatching_State(const ModelSequenceBatching_State& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      dims_(from.dims_),
      initial_state_(from.initial_state_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  input_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    input_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_input_name().empty()) {
    input_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_input_name(), 
      GetArenaForAllocation());
  }
  output_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    output_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_output_name().empty()) {
    output_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_output_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&data_type_, &from.data_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&use_growable_memory_) -
    reinterpret_cast<char*>(&data_type_)) + sizeof(use_growable_memory_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching.State)
}

inline void ModelSequenceBatching_State::SharedCtor() {
input_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  input_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
output_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  output_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&data_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&use_growable_memory_) -
    reinterpret_cast<char*>(&data_type_)) + sizeof(use_growable_memory_));
}

ModelSequenceBatching_State::~ModelSequenceBatching_State() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching.State)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelSequenceBatching_State::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  input_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  output_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ModelSequenceBatching_State::ArenaDtor(void* object) {
  ModelSequenceBatching_State* _this = reinterpret_cast< ModelSequenceBatching_State* >(object);
  (void)_this;
}
void ModelSequenceBatching_State::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelSequenceBatching_State::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelSequenceBatching_State::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching.State)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  initial_state_.Clear();
  input_name_.ClearToEmpty();
  output_name_.ClearToEmpty();
  ::memset(&data_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&use_growable_memory_) -
      reinterpret_cast<char*>(&data_type_)) + sizeof(use_growable_memory_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching_State::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string input_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_input_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelSequenceBatching.State.input_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string output_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_output_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelSequenceBatching.State.output_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.DataType data_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 dims = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelSequenceBatching.InitialState initial_state = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_initial_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool use_same_buffer_for_input_output = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          use_same_buffer_for_input_output_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool use_growable_memory = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          use_growable_memory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching_State::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching.State)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string input_name = 1;
  if (!this->_internal_input_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_input_name().data(), static_cast<int>(this->_internal_input_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelSequenceBatching.State.input_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_input_name(), target);
  }

  // string output_name = 2;
  if (!this->_internal_output_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_output_name().data(), static_cast<int>(this->_internal_output_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelSequenceBatching.State.output_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_output_name(), target);
  }

  // .inference.DataType data_type = 3;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_data_type(), target);
  }

  // repeated int64 dims = 4;
  {
    int byte_size = _dims_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          4, _internal_dims(), byte_size, target);
    }
  }

  // repeated .inference.ModelSequenceBatching.InitialState initial_state = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_initial_state_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_initial_state(i), target, stream);
  }

  // bool use_same_buffer_for_input_output = 6;
  if (this->_internal_use_same_buffer_for_input_output() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_use_same_buffer_for_input_output(), target);
  }

  // bool use_growable_memory = 7;
  if (this->_internal_use_growable_memory() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_use_growable_memory(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching.State)
  return target;
}

size_t ModelSequenceBatching_State::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching.State)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->dims_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _dims_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .inference.ModelSequenceBatching.InitialState initial_state = 5;
  total_size += 1UL * this->_internal_initial_state_size();
  for (const auto& msg : this->initial_state_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string input_name = 1;
  if (!this->_internal_input_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_input_name());
  }

  // string output_name = 2;
  if (!this->_internal_output_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_output_name());
  }

  // .inference.DataType data_type = 3;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  // bool use_same_buffer_for_input_output = 6;
  if (this->_internal_use_same_buffer_for_input_output() != 0) {
    total_size += 1 + 1;
  }

  // bool use_growable_memory = 7;
  if (this->_internal_use_growable_memory() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching_State::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelSequenceBatching_State::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching_State::GetClassData() const { return &_class_data_; }

void ModelSequenceBatching_State::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelSequenceBatching_State *>(to)->MergeFrom(
      static_cast<const ModelSequenceBatching_State &>(from));
}


void ModelSequenceBatching_State::MergeFrom(const ModelSequenceBatching_State& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching.State)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
  initial_state_.MergeFrom(from.initial_state_);
  if (!from._internal_input_name().empty()) {
    _internal_set_input_name(from._internal_input_name());
  }
  if (!from._internal_output_name().empty()) {
    _internal_set_output_name(from._internal_output_name());
  }
  if (from._internal_data_type() != 0) {
    _internal_set_data_type(from._internal_data_type());
  }
  if (from._internal_use_same_buffer_for_input_output() != 0) {
    _internal_set_use_same_buffer_for_input_output(from._internal_use_same_buffer_for_input_output());
  }
  if (from._internal_use_growable_memory() != 0) {
    _internal_set_use_growable_memory(from._internal_use_growable_memory());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching_State::CopyFrom(const ModelSequenceBatching_State& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching.State)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching_State::IsInitialized() const {
  return true;
}

void ModelSequenceBatching_State::InternalSwap(ModelSequenceBatching_State* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  dims_.InternalSwap(&other->dims_);
  initial_state_.InternalSwap(&other->initial_state_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &input_name_, lhs_arena,
      &other->input_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &output_name_, lhs_arena,
      &other->output_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_State, use_growable_memory_)
      + sizeof(ModelSequenceBatching_State::use_growable_memory_)
      - PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_State, data_type_)>(
          reinterpret_cast<char*>(&data_type_),
          reinterpret_cast<char*>(&other->data_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching_State::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[31]);
}

// ===================================================================

class ModelSequenceBatching_StrategyDirect::_Internal {
 public:
};

ModelSequenceBatching_StrategyDirect::ModelSequenceBatching_StrategyDirect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching.StrategyDirect)
}
ModelSequenceBatching_StrategyDirect::ModelSequenceBatching_StrategyDirect(const ModelSequenceBatching_StrategyDirect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&max_queue_delay_microseconds_, &from.max_queue_delay_microseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&minimum_slot_utilization_) -
    reinterpret_cast<char*>(&max_queue_delay_microseconds_)) + sizeof(minimum_slot_utilization_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching.StrategyDirect)
}

inline void ModelSequenceBatching_StrategyDirect::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&max_queue_delay_microseconds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&minimum_slot_utilization_) -
    reinterpret_cast<char*>(&max_queue_delay_microseconds_)) + sizeof(minimum_slot_utilization_));
}

ModelSequenceBatching_StrategyDirect::~ModelSequenceBatching_StrategyDirect() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching.StrategyDirect)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelSequenceBatching_StrategyDirect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelSequenceBatching_StrategyDirect::ArenaDtor(void* object) {
  ModelSequenceBatching_StrategyDirect* _this = reinterpret_cast< ModelSequenceBatching_StrategyDirect* >(object);
  (void)_this;
}
void ModelSequenceBatching_StrategyDirect::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelSequenceBatching_StrategyDirect::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelSequenceBatching_StrategyDirect::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching.StrategyDirect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&max_queue_delay_microseconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&minimum_slot_utilization_) -
      reinterpret_cast<char*>(&max_queue_delay_microseconds_)) + sizeof(minimum_slot_utilization_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching_StrategyDirect::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 max_queue_delay_microseconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          max_queue_delay_microseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float minimum_slot_utilization = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          minimum_slot_utilization_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching_StrategyDirect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching.StrategyDirect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 max_queue_delay_microseconds = 1;
  if (this->_internal_max_queue_delay_microseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_max_queue_delay_microseconds(), target);
  }

  // float minimum_slot_utilization = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minimum_slot_utilization = this->_internal_minimum_slot_utilization();
  uint32_t raw_minimum_slot_utilization;
  memcpy(&raw_minimum_slot_utilization, &tmp_minimum_slot_utilization, sizeof(tmp_minimum_slot_utilization));
  if (raw_minimum_slot_utilization != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_minimum_slot_utilization(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching.StrategyDirect)
  return target;
}

size_t ModelSequenceBatching_StrategyDirect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching.StrategyDirect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 max_queue_delay_microseconds = 1;
  if (this->_internal_max_queue_delay_microseconds() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_max_queue_delay_microseconds());
  }

  // float minimum_slot_utilization = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minimum_slot_utilization = this->_internal_minimum_slot_utilization();
  uint32_t raw_minimum_slot_utilization;
  memcpy(&raw_minimum_slot_utilization, &tmp_minimum_slot_utilization, sizeof(tmp_minimum_slot_utilization));
  if (raw_minimum_slot_utilization != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching_StrategyDirect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelSequenceBatching_StrategyDirect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching_StrategyDirect::GetClassData() const { return &_class_data_; }

void ModelSequenceBatching_StrategyDirect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelSequenceBatching_StrategyDirect *>(to)->MergeFrom(
      static_cast<const ModelSequenceBatching_StrategyDirect &>(from));
}


void ModelSequenceBatching_StrategyDirect::MergeFrom(const ModelSequenceBatching_StrategyDirect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching.StrategyDirect)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_max_queue_delay_microseconds() != 0) {
    _internal_set_max_queue_delay_microseconds(from._internal_max_queue_delay_microseconds());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minimum_slot_utilization = from._internal_minimum_slot_utilization();
  uint32_t raw_minimum_slot_utilization;
  memcpy(&raw_minimum_slot_utilization, &tmp_minimum_slot_utilization, sizeof(tmp_minimum_slot_utilization));
  if (raw_minimum_slot_utilization != 0) {
    _internal_set_minimum_slot_utilization(from._internal_minimum_slot_utilization());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching_StrategyDirect::CopyFrom(const ModelSequenceBatching_StrategyDirect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching.StrategyDirect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching_StrategyDirect::IsInitialized() const {
  return true;
}

void ModelSequenceBatching_StrategyDirect::InternalSwap(ModelSequenceBatching_StrategyDirect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_StrategyDirect, minimum_slot_utilization_)
      + sizeof(ModelSequenceBatching_StrategyDirect::minimum_slot_utilization_)
      - PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_StrategyDirect, max_queue_delay_microseconds_)>(
          reinterpret_cast<char*>(&max_queue_delay_microseconds_),
          reinterpret_cast<char*>(&other->max_queue_delay_microseconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching_StrategyDirect::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[32]);
}

// ===================================================================

class ModelSequenceBatching_StrategyOldest::_Internal {
 public:
};

ModelSequenceBatching_StrategyOldest::ModelSequenceBatching_StrategyOldest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  preferred_batch_size_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching.StrategyOldest)
}
ModelSequenceBatching_StrategyOldest::ModelSequenceBatching_StrategyOldest(const ModelSequenceBatching_StrategyOldest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      preferred_batch_size_(from.preferred_batch_size_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&max_candidate_sequences_, &from.max_candidate_sequences_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_queue_delay_microseconds_) -
    reinterpret_cast<char*>(&max_candidate_sequences_)) + sizeof(max_queue_delay_microseconds_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching.StrategyOldest)
}

inline void ModelSequenceBatching_StrategyOldest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&max_candidate_sequences_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_queue_delay_microseconds_) -
    reinterpret_cast<char*>(&max_candidate_sequences_)) + sizeof(max_queue_delay_microseconds_));
}

ModelSequenceBatching_StrategyOldest::~ModelSequenceBatching_StrategyOldest() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching.StrategyOldest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelSequenceBatching_StrategyOldest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelSequenceBatching_StrategyOldest::ArenaDtor(void* object) {
  ModelSequenceBatching_StrategyOldest* _this = reinterpret_cast< ModelSequenceBatching_StrategyOldest* >(object);
  (void)_this;
}
void ModelSequenceBatching_StrategyOldest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelSequenceBatching_StrategyOldest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelSequenceBatching_StrategyOldest::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching.StrategyOldest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  preferred_batch_size_.Clear();
  ::memset(&max_candidate_sequences_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_queue_delay_microseconds_) -
      reinterpret_cast<char*>(&max_candidate_sequences_)) + sizeof(max_queue_delay_microseconds_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching_StrategyOldest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 max_candidate_sequences = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          max_candidate_sequences_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 preferred_batch_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_preferred_batch_size(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 max_queue_delay_microseconds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          max_queue_delay_microseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool preserve_ordering = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          preserve_ordering_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching_StrategyOldest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching.StrategyOldest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 max_candidate_sequences = 1;
  if (this->_internal_max_candidate_sequences() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_max_candidate_sequences(), target);
  }

  // repeated int32 preferred_batch_size = 2;
  {
    int byte_size = _preferred_batch_size_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_preferred_batch_size(), byte_size, target);
    }
  }

  // uint64 max_queue_delay_microseconds = 3;
  if (this->_internal_max_queue_delay_microseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_max_queue_delay_microseconds(), target);
  }

  // bool preserve_ordering = 4;
  if (this->_internal_preserve_ordering() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_preserve_ordering(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching.StrategyOldest)
  return target;
}

size_t ModelSequenceBatching_StrategyOldest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching.StrategyOldest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 preferred_batch_size = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->preferred_batch_size_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _preferred_batch_size_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int32 max_candidate_sequences = 1;
  if (this->_internal_max_candidate_sequences() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_max_candidate_sequences());
  }

  // bool preserve_ordering = 4;
  if (this->_internal_preserve_ordering() != 0) {
    total_size += 1 + 1;
  }

  // uint64 max_queue_delay_microseconds = 3;
  if (this->_internal_max_queue_delay_microseconds() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_max_queue_delay_microseconds());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching_StrategyOldest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelSequenceBatching_StrategyOldest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching_StrategyOldest::GetClassData() const { return &_class_data_; }

void ModelSequenceBatching_StrategyOldest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelSequenceBatching_StrategyOldest *>(to)->MergeFrom(
      static_cast<const ModelSequenceBatching_StrategyOldest &>(from));
}


void ModelSequenceBatching_StrategyOldest::MergeFrom(const ModelSequenceBatching_StrategyOldest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching.StrategyOldest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  preferred_batch_size_.MergeFrom(from.preferred_batch_size_);
  if (from._internal_max_candidate_sequences() != 0) {
    _internal_set_max_candidate_sequences(from._internal_max_candidate_sequences());
  }
  if (from._internal_preserve_ordering() != 0) {
    _internal_set_preserve_ordering(from._internal_preserve_ordering());
  }
  if (from._internal_max_queue_delay_microseconds() != 0) {
    _internal_set_max_queue_delay_microseconds(from._internal_max_queue_delay_microseconds());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching_StrategyOldest::CopyFrom(const ModelSequenceBatching_StrategyOldest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching.StrategyOldest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching_StrategyOldest::IsInitialized() const {
  return true;
}

void ModelSequenceBatching_StrategyOldest::InternalSwap(ModelSequenceBatching_StrategyOldest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  preferred_batch_size_.InternalSwap(&other->preferred_batch_size_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_StrategyOldest, max_queue_delay_microseconds_)
      + sizeof(ModelSequenceBatching_StrategyOldest::max_queue_delay_microseconds_)
      - PROTOBUF_FIELD_OFFSET(ModelSequenceBatching_StrategyOldest, max_candidate_sequences_)>(
          reinterpret_cast<char*>(&max_candidate_sequences_),
          reinterpret_cast<char*>(&other->max_candidate_sequences_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching_StrategyOldest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[33]);
}

// ===================================================================

class ModelSequenceBatching::_Internal {
 public:
  static const ::inference::ModelSequenceBatching_StrategyDirect& direct(const ModelSequenceBatching* msg);
  static const ::inference::ModelSequenceBatching_StrategyOldest& oldest(const ModelSequenceBatching* msg);
};

const ::inference::ModelSequenceBatching_StrategyDirect&
ModelSequenceBatching::_Internal::direct(const ModelSequenceBatching* msg) {
  return *msg->strategy_choice_.direct_;
}
const ::inference::ModelSequenceBatching_StrategyOldest&
ModelSequenceBatching::_Internal::oldest(const ModelSequenceBatching* msg) {
  return *msg->strategy_choice_.oldest_;
}
void ModelSequenceBatching::set_allocated_direct(::inference::ModelSequenceBatching_StrategyDirect* direct) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_strategy_choice();
  if (direct) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::inference::ModelSequenceBatching_StrategyDirect>::GetOwningArena(direct);
    if (message_arena != submessage_arena) {
      direct = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direct, submessage_arena);
    }
    set_has_direct();
    strategy_choice_.direct_ = direct;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelSequenceBatching.direct)
}
void ModelSequenceBatching::set_allocated_oldest(::inference::ModelSequenceBatching_StrategyOldest* oldest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_strategy_choice();
  if (oldest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::inference::ModelSequenceBatching_StrategyOldest>::GetOwningArena(oldest);
    if (message_arena != submessage_arena) {
      oldest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oldest, submessage_arena);
    }
    set_has_oldest();
    strategy_choice_.oldest_ = oldest;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelSequenceBatching.oldest)
}
ModelSequenceBatching::ModelSequenceBatching(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  control_input_(arena),
  state_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelSequenceBatching)
}
ModelSequenceBatching::ModelSequenceBatching(const ModelSequenceBatching& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      control_input_(from.control_input_),
      state_(from.state_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&max_sequence_idle_microseconds_, &from.max_sequence_idle_microseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&iterative_sequence_) -
    reinterpret_cast<char*>(&max_sequence_idle_microseconds_)) + sizeof(iterative_sequence_));
  clear_has_strategy_choice();
  switch (from.strategy_choice_case()) {
    case kDirect: {
      _internal_mutable_direct()->::inference::ModelSequenceBatching_StrategyDirect::MergeFrom(from._internal_direct());
      break;
    }
    case kOldest: {
      _internal_mutable_oldest()->::inference::ModelSequenceBatching_StrategyOldest::MergeFrom(from._internal_oldest());
      break;
    }
    case STRATEGY_CHOICE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelSequenceBatching)
}

inline void ModelSequenceBatching::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&max_sequence_idle_microseconds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&iterative_sequence_) -
    reinterpret_cast<char*>(&max_sequence_idle_microseconds_)) + sizeof(iterative_sequence_));
clear_has_strategy_choice();
}

ModelSequenceBatching::~ModelSequenceBatching() {
  // @@protoc_insertion_point(destructor:inference.ModelSequenceBatching)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelSequenceBatching::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_strategy_choice()) {
    clear_strategy_choice();
  }
}

void ModelSequenceBatching::ArenaDtor(void* object) {
  ModelSequenceBatching* _this = reinterpret_cast< ModelSequenceBatching* >(object);
  (void)_this;
}
void ModelSequenceBatching::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelSequenceBatching::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelSequenceBatching::clear_strategy_choice() {
// @@protoc_insertion_point(one_of_clear_start:inference.ModelSequenceBatching)
  switch (strategy_choice_case()) {
    case kDirect: {
      if (GetArenaForAllocation() == nullptr) {
        delete strategy_choice_.direct_;
      }
      break;
    }
    case kOldest: {
      if (GetArenaForAllocation() == nullptr) {
        delete strategy_choice_.oldest_;
      }
      break;
    }
    case STRATEGY_CHOICE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = STRATEGY_CHOICE_NOT_SET;
}


void ModelSequenceBatching::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelSequenceBatching)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  control_input_.Clear();
  state_.Clear();
  ::memset(&max_sequence_idle_microseconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&iterative_sequence_) -
      reinterpret_cast<char*>(&max_sequence_idle_microseconds_)) + sizeof(iterative_sequence_));
  clear_strategy_choice();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelSequenceBatching::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 max_sequence_idle_microseconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          max_sequence_idle_microseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_control_input(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelSequenceBatching.StrategyDirect direct = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_direct(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelSequenceBatching.StrategyOldest oldest = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldest(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelSequenceBatching.State state = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool iterative_sequence = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          iterative_sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelSequenceBatching::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelSequenceBatching)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 max_sequence_idle_microseconds = 1;
  if (this->_internal_max_sequence_idle_microseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_max_sequence_idle_microseconds(), target);
  }

  // repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_control_input_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_control_input(i), target, stream);
  }

  // .inference.ModelSequenceBatching.StrategyDirect direct = 3;
  if (_internal_has_direct()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::direct(this), target, stream);
  }

  // .inference.ModelSequenceBatching.StrategyOldest oldest = 4;
  if (_internal_has_oldest()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::oldest(this), target, stream);
  }

  // repeated .inference.ModelSequenceBatching.State state = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_state_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_state(i), target, stream);
  }

  // bool iterative_sequence = 6;
  if (this->_internal_iterative_sequence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_iterative_sequence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelSequenceBatching)
  return target;
}

size_t ModelSequenceBatching::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelSequenceBatching)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;
  total_size += 1UL * this->_internal_control_input_size();
  for (const auto& msg : this->control_input_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .inference.ModelSequenceBatching.State state = 5;
  total_size += 1UL * this->_internal_state_size();
  for (const auto& msg : this->state_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint64 max_sequence_idle_microseconds = 1;
  if (this->_internal_max_sequence_idle_microseconds() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_max_sequence_idle_microseconds());
  }

  // bool iterative_sequence = 6;
  if (this->_internal_iterative_sequence() != 0) {
    total_size += 1 + 1;
  }

  switch (strategy_choice_case()) {
    // .inference.ModelSequenceBatching.StrategyDirect direct = 3;
    case kDirect: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *strategy_choice_.direct_);
      break;
    }
    // .inference.ModelSequenceBatching.StrategyOldest oldest = 4;
    case kOldest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *strategy_choice_.oldest_);
      break;
    }
    case STRATEGY_CHOICE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelSequenceBatching::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelSequenceBatching::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelSequenceBatching::GetClassData() const { return &_class_data_; }

void ModelSequenceBatching::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelSequenceBatching *>(to)->MergeFrom(
      static_cast<const ModelSequenceBatching &>(from));
}


void ModelSequenceBatching::MergeFrom(const ModelSequenceBatching& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelSequenceBatching)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  control_input_.MergeFrom(from.control_input_);
  state_.MergeFrom(from.state_);
  if (from._internal_max_sequence_idle_microseconds() != 0) {
    _internal_set_max_sequence_idle_microseconds(from._internal_max_sequence_idle_microseconds());
  }
  if (from._internal_iterative_sequence() != 0) {
    _internal_set_iterative_sequence(from._internal_iterative_sequence());
  }
  switch (from.strategy_choice_case()) {
    case kDirect: {
      _internal_mutable_direct()->::inference::ModelSequenceBatching_StrategyDirect::MergeFrom(from._internal_direct());
      break;
    }
    case kOldest: {
      _internal_mutable_oldest()->::inference::ModelSequenceBatching_StrategyOldest::MergeFrom(from._internal_oldest());
      break;
    }
    case STRATEGY_CHOICE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelSequenceBatching::CopyFrom(const ModelSequenceBatching& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelSequenceBatching)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelSequenceBatching::IsInitialized() const {
  return true;
}

void ModelSequenceBatching::InternalSwap(ModelSequenceBatching* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  control_input_.InternalSwap(&other->control_input_);
  state_.InternalSwap(&other->state_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelSequenceBatching, iterative_sequence_)
      + sizeof(ModelSequenceBatching::iterative_sequence_)
      - PROTOBUF_FIELD_OFFSET(ModelSequenceBatching, max_sequence_idle_microseconds_)>(
          reinterpret_cast<char*>(&max_sequence_idle_microseconds_),
          reinterpret_cast<char*>(&other->max_sequence_idle_microseconds_));
  swap(strategy_choice_, other->strategy_choice_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelSequenceBatching::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[34]);
}

// ===================================================================

ModelEnsembling_Step_InputMapEntry_DoNotUse::ModelEnsembling_Step_InputMapEntry_DoNotUse() {}
ModelEnsembling_Step_InputMapEntry_DoNotUse::ModelEnsembling_Step_InputMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelEnsembling_Step_InputMapEntry_DoNotUse::MergeFrom(const ModelEnsembling_Step_InputMapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelEnsembling_Step_InputMapEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[35]);
}

// ===================================================================

ModelEnsembling_Step_OutputMapEntry_DoNotUse::ModelEnsembling_Step_OutputMapEntry_DoNotUse() {}
ModelEnsembling_Step_OutputMapEntry_DoNotUse::ModelEnsembling_Step_OutputMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelEnsembling_Step_OutputMapEntry_DoNotUse::MergeFrom(const ModelEnsembling_Step_OutputMapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelEnsembling_Step_OutputMapEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[36]);
}

// ===================================================================

class ModelEnsembling_Step::_Internal {
 public:
};

ModelEnsembling_Step::ModelEnsembling_Step(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  input_map_(arena),
  output_map_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelEnsembling.Step)
}
ModelEnsembling_Step::ModelEnsembling_Step(const ModelEnsembling_Step& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  input_map_.MergeFrom(from.input_map_);
  output_map_.MergeFrom(from.output_map_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model_name().empty()) {
    model_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_model_name(), 
      GetArenaForAllocation());
  }
  model_namespace_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_namespace_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model_namespace().empty()) {
    model_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_model_namespace(), 
      GetArenaForAllocation());
  }
  model_version_ = from.model_version_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelEnsembling.Step)
}

inline void ModelEnsembling_Step::SharedCtor() {
model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_namespace_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_namespace_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_version_ = int64_t{0};
}

ModelEnsembling_Step::~ModelEnsembling_Step() {
  // @@protoc_insertion_point(destructor:inference.ModelEnsembling.Step)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelEnsembling_Step::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_namespace_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ModelEnsembling_Step::ArenaDtor(void* object) {
  ModelEnsembling_Step* _this = reinterpret_cast< ModelEnsembling_Step* >(object);
  (void)_this;
  _this->input_map_. ~MapField();
  _this->output_map_. ~MapField();
}
inline void ModelEnsembling_Step::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ModelEnsembling_Step::ArenaDtor);
  }
}
void ModelEnsembling_Step::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelEnsembling_Step::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelEnsembling.Step)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_map_.Clear();
  output_map_.Clear();
  model_name_.ClearToEmpty();
  model_namespace_.ClearToEmpty();
  model_version_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelEnsembling_Step::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelEnsembling.Step.model_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 model_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          model_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> input_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&input_map_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> output_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&output_map_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string model_namespace = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_model_namespace();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelEnsembling.Step.model_namespace"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelEnsembling_Step::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelEnsembling.Step)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string model_name = 1;
  if (!this->_internal_model_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelEnsembling.Step.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // int64 model_version = 2;
  if (this->_internal_model_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_model_version(), target);
  }

  // map<string, string> input_map = 3;
  if (!this->_internal_input_map().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelEnsembling.Step.InputMapEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelEnsembling.Step.InputMapEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_input_map().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_input_map().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_input_map().begin();
          it != this->_internal_input_map().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelEnsembling_Step_InputMapEntry_DoNotUse::Funcs::InternalSerialize(3, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_input_map().begin();
          it != this->_internal_input_map().end(); ++it) {
        target = ModelEnsembling_Step_InputMapEntry_DoNotUse::Funcs::InternalSerialize(3, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // map<string, string> output_map = 4;
  if (!this->_internal_output_map().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelEnsembling.Step.OutputMapEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelEnsembling.Step.OutputMapEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_output_map().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_output_map().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_output_map().begin();
          it != this->_internal_output_map().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelEnsembling_Step_OutputMapEntry_DoNotUse::Funcs::InternalSerialize(4, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_output_map().begin();
          it != this->_internal_output_map().end(); ++it) {
        target = ModelEnsembling_Step_OutputMapEntry_DoNotUse::Funcs::InternalSerialize(4, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // string model_namespace = 5;
  if (!this->_internal_model_namespace().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model_namespace().data(), static_cast<int>(this->_internal_model_namespace().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelEnsembling.Step.model_namespace");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_model_namespace(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelEnsembling.Step)
  return target;
}

size_t ModelEnsembling_Step::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelEnsembling.Step)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> input_map = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_input_map_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_input_map().begin();
      it != this->_internal_input_map().end(); ++it) {
    total_size += ModelEnsembling_Step_InputMapEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, string> output_map = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_output_map_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_output_map().begin();
      it != this->_internal_output_map().end(); ++it) {
    total_size += ModelEnsembling_Step_OutputMapEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string model_name = 1;
  if (!this->_internal_model_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  // string model_namespace = 5;
  if (!this->_internal_model_namespace().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_namespace());
  }

  // int64 model_version = 2;
  if (this->_internal_model_version() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_model_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelEnsembling_Step::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelEnsembling_Step::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelEnsembling_Step::GetClassData() const { return &_class_data_; }

void ModelEnsembling_Step::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelEnsembling_Step *>(to)->MergeFrom(
      static_cast<const ModelEnsembling_Step &>(from));
}


void ModelEnsembling_Step::MergeFrom(const ModelEnsembling_Step& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelEnsembling.Step)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  input_map_.MergeFrom(from.input_map_);
  output_map_.MergeFrom(from.output_map_);
  if (!from._internal_model_name().empty()) {
    _internal_set_model_name(from._internal_model_name());
  }
  if (!from._internal_model_namespace().empty()) {
    _internal_set_model_namespace(from._internal_model_namespace());
  }
  if (from._internal_model_version() != 0) {
    _internal_set_model_version(from._internal_model_version());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelEnsembling_Step::CopyFrom(const ModelEnsembling_Step& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelEnsembling.Step)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelEnsembling_Step::IsInitialized() const {
  return true;
}

void ModelEnsembling_Step::InternalSwap(ModelEnsembling_Step* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  input_map_.InternalSwap(&other->input_map_);
  output_map_.InternalSwap(&other->output_map_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &model_name_, lhs_arena,
      &other->model_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &model_namespace_, lhs_arena,
      &other->model_namespace_, rhs_arena
  );
  swap(model_version_, other->model_version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelEnsembling_Step::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[37]);
}

// ===================================================================

class ModelEnsembling::_Internal {
 public:
};

ModelEnsembling::ModelEnsembling(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  step_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelEnsembling)
}
ModelEnsembling::ModelEnsembling(const ModelEnsembling& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      step_(from.step_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelEnsembling)
}

inline void ModelEnsembling::SharedCtor() {
}

ModelEnsembling::~ModelEnsembling() {
  // @@protoc_insertion_point(destructor:inference.ModelEnsembling)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelEnsembling::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelEnsembling::ArenaDtor(void* object) {
  ModelEnsembling* _this = reinterpret_cast< ModelEnsembling* >(object);
  (void)_this;
}
void ModelEnsembling::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelEnsembling::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelEnsembling::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelEnsembling)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  step_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelEnsembling::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .inference.ModelEnsembling.Step step = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_step(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelEnsembling::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelEnsembling)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .inference.ModelEnsembling.Step step = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_step_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_step(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelEnsembling)
  return target;
}

size_t ModelEnsembling::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelEnsembling)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelEnsembling.Step step = 1;
  total_size += 1UL * this->_internal_step_size();
  for (const auto& msg : this->step_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelEnsembling::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelEnsembling::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelEnsembling::GetClassData() const { return &_class_data_; }

void ModelEnsembling::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelEnsembling *>(to)->MergeFrom(
      static_cast<const ModelEnsembling &>(from));
}


void ModelEnsembling::MergeFrom(const ModelEnsembling& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelEnsembling)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  step_.MergeFrom(from.step_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelEnsembling::CopyFrom(const ModelEnsembling& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelEnsembling)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelEnsembling::IsInitialized() const {
  return true;
}

void ModelEnsembling::InternalSwap(ModelEnsembling* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  step_.InternalSwap(&other->step_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelEnsembling::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[38]);
}

// ===================================================================

class ModelParameter::_Internal {
 public:
};

ModelParameter::ModelParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelParameter)
}
ModelParameter::ModelParameter(const ModelParameter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    string_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_string_value().empty()) {
    string_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_string_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelParameter)
}

inline void ModelParameter::SharedCtor() {
string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  string_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelParameter::~ModelParameter() {
  // @@protoc_insertion_point(destructor:inference.ModelParameter)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelParameter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  string_value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ModelParameter::ArenaDtor(void* object) {
  ModelParameter* _this = reinterpret_cast< ModelParameter* >(object);
  (void)_this;
}
void ModelParameter::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelParameter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelParameter::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelParameter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  string_value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelParameter::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string string_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_string_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelParameter.string_value"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelParameter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelParameter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string string_value = 1;
  if (!this->_internal_string_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_string_value().data(), static_cast<int>(this->_internal_string_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelParameter.string_value");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_string_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelParameter)
  return target;
}

size_t ModelParameter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelParameter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string string_value = 1;
  if (!this->_internal_string_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_string_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelParameter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelParameter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelParameter::GetClassData() const { return &_class_data_; }

void ModelParameter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelParameter *>(to)->MergeFrom(
      static_cast<const ModelParameter &>(from));
}


void ModelParameter::MergeFrom(const ModelParameter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelParameter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_string_value().empty()) {
    _internal_set_string_value(from._internal_string_value());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelParameter::CopyFrom(const ModelParameter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelParameter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelParameter::IsInitialized() const {
  return true;
}

void ModelParameter::InternalSwap(ModelParameter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &string_value_, lhs_arena,
      &other->string_value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelParameter::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[39]);
}

// ===================================================================

class ModelWarmup_Input::_Internal {
 public:
};

ModelWarmup_Input::ModelWarmup_Input(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  dims_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelWarmup.Input)
}
ModelWarmup_Input::ModelWarmup_Input(const ModelWarmup_Input& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      dims_(from.dims_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_type_ = from.data_type_;
  clear_has_input_data_type();
  switch (from.input_data_type_case()) {
    case kZeroData: {
      _internal_set_zero_data(from._internal_zero_data());
      break;
    }
    case kRandomData: {
      _internal_set_random_data(from._internal_random_data());
      break;
    }
    case kInputDataFile: {
      _internal_set_input_data_file(from._internal_input_data_file());
      break;
    }
    case INPUT_DATA_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelWarmup.Input)
}

inline void ModelWarmup_Input::SharedCtor() {
data_type_ = 0;
clear_has_input_data_type();
}

ModelWarmup_Input::~ModelWarmup_Input() {
  // @@protoc_insertion_point(destructor:inference.ModelWarmup.Input)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelWarmup_Input::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_input_data_type()) {
    clear_input_data_type();
  }
}

void ModelWarmup_Input::ArenaDtor(void* object) {
  ModelWarmup_Input* _this = reinterpret_cast< ModelWarmup_Input* >(object);
  (void)_this;
}
void ModelWarmup_Input::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelWarmup_Input::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelWarmup_Input::clear_input_data_type() {
// @@protoc_insertion_point(one_of_clear_start:inference.ModelWarmup.Input)
  switch (input_data_type_case()) {
    case kZeroData: {
      // No need to clear
      break;
    }
    case kRandomData: {
      // No need to clear
      break;
    }
    case kInputDataFile: {
      input_data_type_.input_data_file_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
      break;
    }
    case INPUT_DATA_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = INPUT_DATA_TYPE_NOT_SET;
}


void ModelWarmup_Input::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelWarmup.Input)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  data_type_ = 0;
  clear_input_data_type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelWarmup_Input::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .inference.DataType data_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::inference::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 dims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool zero_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_zero_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool random_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_random_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string input_data_file = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_input_data_file();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelWarmup.Input.input_data_file"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelWarmup_Input::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelWarmup.Input)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .inference.DataType data_type = 1;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_data_type(), target);
  }

  // repeated int64 dims = 2;
  {
    int byte_size = _dims_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_dims(), byte_size, target);
    }
  }

  // bool zero_data = 3;
  if (_internal_has_zero_data()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_zero_data(), target);
  }

  // bool random_data = 4;
  if (_internal_has_random_data()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_random_data(), target);
  }

  // string input_data_file = 5;
  if (_internal_has_input_data_file()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_input_data_file().data(), static_cast<int>(this->_internal_input_data_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelWarmup.Input.input_data_file");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_input_data_file(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelWarmup.Input)
  return target;
}

size_t ModelWarmup_Input::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelWarmup.Input)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->dims_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _dims_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .inference.DataType data_type = 1;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  switch (input_data_type_case()) {
    // bool zero_data = 3;
    case kZeroData: {
      total_size += 1 + 1;
      break;
    }
    // bool random_data = 4;
    case kRandomData: {
      total_size += 1 + 1;
      break;
    }
    // string input_data_file = 5;
    case kInputDataFile: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_input_data_file());
      break;
    }
    case INPUT_DATA_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelWarmup_Input::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelWarmup_Input::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelWarmup_Input::GetClassData() const { return &_class_data_; }

void ModelWarmup_Input::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelWarmup_Input *>(to)->MergeFrom(
      static_cast<const ModelWarmup_Input &>(from));
}


void ModelWarmup_Input::MergeFrom(const ModelWarmup_Input& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelWarmup.Input)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
  if (from._internal_data_type() != 0) {
    _internal_set_data_type(from._internal_data_type());
  }
  switch (from.input_data_type_case()) {
    case kZeroData: {
      _internal_set_zero_data(from._internal_zero_data());
      break;
    }
    case kRandomData: {
      _internal_set_random_data(from._internal_random_data());
      break;
    }
    case kInputDataFile: {
      _internal_set_input_data_file(from._internal_input_data_file());
      break;
    }
    case INPUT_DATA_TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelWarmup_Input::CopyFrom(const ModelWarmup_Input& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelWarmup.Input)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelWarmup_Input::IsInitialized() const {
  return true;
}

void ModelWarmup_Input::InternalSwap(ModelWarmup_Input* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  dims_.InternalSwap(&other->dims_);
  swap(data_type_, other->data_type_);
  swap(input_data_type_, other->input_data_type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelWarmup_Input::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[40]);
}

// ===================================================================

ModelWarmup_InputsEntry_DoNotUse::ModelWarmup_InputsEntry_DoNotUse() {}
ModelWarmup_InputsEntry_DoNotUse::ModelWarmup_InputsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelWarmup_InputsEntry_DoNotUse::MergeFrom(const ModelWarmup_InputsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelWarmup_InputsEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[41]);
}

// ===================================================================

class ModelWarmup::_Internal {
 public:
};

ModelWarmup::ModelWarmup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  inputs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelWarmup)
}
ModelWarmup::ModelWarmup(const ModelWarmup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  inputs_.MergeFrom(from.inputs_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&batch_size_, &from.batch_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&batch_size_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:inference.ModelWarmup)
}

inline void ModelWarmup::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&batch_size_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&batch_size_)) + sizeof(count_));
}

ModelWarmup::~ModelWarmup() {
  // @@protoc_insertion_point(destructor:inference.ModelWarmup)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelWarmup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ModelWarmup::ArenaDtor(void* object) {
  ModelWarmup* _this = reinterpret_cast< ModelWarmup* >(object);
  (void)_this;
  _this->inputs_. ~MapField();
}
inline void ModelWarmup::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ModelWarmup::ArenaDtor);
  }
}
void ModelWarmup::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelWarmup::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelWarmup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  inputs_.Clear();
  name_.ClearToEmpty();
  ::memset(&batch_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&count_) -
      reinterpret_cast<char*>(&batch_size_)) + sizeof(count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelWarmup::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelWarmup.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 batch_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .inference.ModelWarmup.Input> inputs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&inputs_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelWarmup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelWarmup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelWarmup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // uint32 batch_size = 2;
  if (this->_internal_batch_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_batch_size(), target);
  }

  // map<string, .inference.ModelWarmup.Input> inputs = 3;
  if (!this->_internal_inputs().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelWarmup.InputsEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_inputs().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_inputs().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >::const_iterator
          it = this->_internal_inputs().begin();
          it != this->_internal_inputs().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelWarmup_InputsEntry_DoNotUse::Funcs::InternalSerialize(3, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >::const_iterator
          it = this->_internal_inputs().begin();
          it != this->_internal_inputs().end(); ++it) {
        target = ModelWarmup_InputsEntry_DoNotUse::Funcs::InternalSerialize(3, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // uint32 count = 4;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelWarmup)
  return target;
}

size_t ModelWarmup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelWarmup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .inference.ModelWarmup.Input> inputs = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_inputs_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >::const_iterator
      it = this->_internal_inputs().begin();
      it != this->_internal_inputs().end(); ++it) {
    total_size += ModelWarmup_InputsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // uint32 batch_size = 2;
  if (this->_internal_batch_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_batch_size());
  }

  // uint32 count = 4;
  if (this->_internal_count() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelWarmup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelWarmup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelWarmup::GetClassData() const { return &_class_data_; }

void ModelWarmup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelWarmup *>(to)->MergeFrom(
      static_cast<const ModelWarmup &>(from));
}


void ModelWarmup::MergeFrom(const ModelWarmup& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelWarmup)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  inputs_.MergeFrom(from.inputs_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_batch_size() != 0) {
    _internal_set_batch_size(from._internal_batch_size());
  }
  if (from._internal_count() != 0) {
    _internal_set_count(from._internal_count());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelWarmup::CopyFrom(const ModelWarmup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelWarmup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelWarmup::IsInitialized() const {
  return true;
}

void ModelWarmup::InternalSwap(ModelWarmup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  inputs_.InternalSwap(&other->inputs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelWarmup, count_)
      + sizeof(ModelWarmup::count_)
      - PROTOBUF_FIELD_OFFSET(ModelWarmup, batch_size_)>(
          reinterpret_cast<char*>(&batch_size_),
          reinterpret_cast<char*>(&other->batch_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelWarmup::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[42]);
}

// ===================================================================

class ModelOperations::_Internal {
 public:
};

ModelOperations::ModelOperations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  op_library_filename_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelOperations)
}
ModelOperations::ModelOperations(const ModelOperations& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      op_library_filename_(from.op_library_filename_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelOperations)
}

inline void ModelOperations::SharedCtor() {
}

ModelOperations::~ModelOperations() {
  // @@protoc_insertion_point(destructor:inference.ModelOperations)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelOperations::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelOperations::ArenaDtor(void* object) {
  ModelOperations* _this = reinterpret_cast< ModelOperations* >(object);
  (void)_this;
}
void ModelOperations::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelOperations::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelOperations::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelOperations)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  op_library_filename_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelOperations::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string op_library_filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_op_library_filename();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelOperations.op_library_filename"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelOperations::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelOperations)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string op_library_filename = 1;
  for (int i = 0, n = this->_internal_op_library_filename_size(); i < n; i++) {
    const auto& s = this->_internal_op_library_filename(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelOperations.op_library_filename");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelOperations)
  return target;
}

size_t ModelOperations::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelOperations)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string op_library_filename = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(op_library_filename_.size());
  for (int i = 0, n = op_library_filename_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      op_library_filename_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelOperations::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelOperations::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelOperations::GetClassData() const { return &_class_data_; }

void ModelOperations::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelOperations *>(to)->MergeFrom(
      static_cast<const ModelOperations &>(from));
}


void ModelOperations::MergeFrom(const ModelOperations& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelOperations)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  op_library_filename_.MergeFrom(from.op_library_filename_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelOperations::CopyFrom(const ModelOperations& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelOperations)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelOperations::IsInitialized() const {
  return true;
}

void ModelOperations::InternalSwap(ModelOperations* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  op_library_filename_.InternalSwap(&other->op_library_filename_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelOperations::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[43]);
}

// ===================================================================

class ModelTransactionPolicy::_Internal {
 public:
};

ModelTransactionPolicy::ModelTransactionPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelTransactionPolicy)
}
ModelTransactionPolicy::ModelTransactionPolicy(const ModelTransactionPolicy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  decoupled_ = from.decoupled_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelTransactionPolicy)
}

inline void ModelTransactionPolicy::SharedCtor() {
decoupled_ = false;
}

ModelTransactionPolicy::~ModelTransactionPolicy() {
  // @@protoc_insertion_point(destructor:inference.ModelTransactionPolicy)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelTransactionPolicy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelTransactionPolicy::ArenaDtor(void* object) {
  ModelTransactionPolicy* _this = reinterpret_cast< ModelTransactionPolicy* >(object);
  (void)_this;
}
void ModelTransactionPolicy::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelTransactionPolicy::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelTransactionPolicy::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelTransactionPolicy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  decoupled_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelTransactionPolicy::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool decoupled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          decoupled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelTransactionPolicy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelTransactionPolicy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool decoupled = 1;
  if (this->_internal_decoupled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_decoupled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelTransactionPolicy)
  return target;
}

size_t ModelTransactionPolicy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelTransactionPolicy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool decoupled = 1;
  if (this->_internal_decoupled() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelTransactionPolicy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelTransactionPolicy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelTransactionPolicy::GetClassData() const { return &_class_data_; }

void ModelTransactionPolicy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelTransactionPolicy *>(to)->MergeFrom(
      static_cast<const ModelTransactionPolicy &>(from));
}


void ModelTransactionPolicy::MergeFrom(const ModelTransactionPolicy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelTransactionPolicy)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_decoupled() != 0) {
    _internal_set_decoupled(from._internal_decoupled());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelTransactionPolicy::CopyFrom(const ModelTransactionPolicy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelTransactionPolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelTransactionPolicy::IsInitialized() const {
  return true;
}

void ModelTransactionPolicy::InternalSwap(ModelTransactionPolicy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(decoupled_, other->decoupled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelTransactionPolicy::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[44]);
}

// ===================================================================

ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse() {}
ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::MergeFrom(const ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[45]);
}

// ===================================================================

class ModelRepositoryAgents_Agent::_Internal {
 public:
};

ModelRepositoryAgents_Agent::ModelRepositoryAgents_Agent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  parameters_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelRepositoryAgents.Agent)
}
ModelRepositoryAgents_Agent::ModelRepositoryAgents_Agent(const ModelRepositoryAgents_Agent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  parameters_.MergeFrom(from.parameters_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelRepositoryAgents.Agent)
}

inline void ModelRepositoryAgents_Agent::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelRepositoryAgents_Agent::~ModelRepositoryAgents_Agent() {
  // @@protoc_insertion_point(destructor:inference.ModelRepositoryAgents.Agent)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelRepositoryAgents_Agent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ModelRepositoryAgents_Agent::ArenaDtor(void* object) {
  ModelRepositoryAgents_Agent* _this = reinterpret_cast< ModelRepositoryAgents_Agent* >(object);
  (void)_this;
  _this->parameters_. ~MapField();
}
inline void ModelRepositoryAgents_Agent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ModelRepositoryAgents_Agent::ArenaDtor);
  }
}
void ModelRepositoryAgents_Agent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelRepositoryAgents_Agent::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelRepositoryAgents.Agent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  parameters_.Clear();
  name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelRepositoryAgents_Agent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelRepositoryAgents.Agent.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> parameters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&parameters_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelRepositoryAgents_Agent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelRepositoryAgents.Agent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelRepositoryAgents.Agent.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // map<string, string> parameters = 2;
  if (!this->_internal_parameters().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelRepositoryAgents.Agent.ParametersEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelRepositoryAgents.Agent.ParametersEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_parameters().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_parameters().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_parameters().begin();
          it != this->_internal_parameters().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::Funcs::InternalSerialize(2, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_parameters().begin();
          it != this->_internal_parameters().end(); ++it) {
        target = ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::Funcs::InternalSerialize(2, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelRepositoryAgents.Agent)
  return target;
}

size_t ModelRepositoryAgents_Agent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelRepositoryAgents.Agent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> parameters = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_parameters_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_parameters().begin();
      it != this->_internal_parameters().end(); ++it) {
    total_size += ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelRepositoryAgents_Agent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelRepositoryAgents_Agent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelRepositoryAgents_Agent::GetClassData() const { return &_class_data_; }

void ModelRepositoryAgents_Agent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelRepositoryAgents_Agent *>(to)->MergeFrom(
      static_cast<const ModelRepositoryAgents_Agent &>(from));
}


void ModelRepositoryAgents_Agent::MergeFrom(const ModelRepositoryAgents_Agent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelRepositoryAgents.Agent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  parameters_.MergeFrom(from.parameters_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelRepositoryAgents_Agent::CopyFrom(const ModelRepositoryAgents_Agent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelRepositoryAgents.Agent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelRepositoryAgents_Agent::IsInitialized() const {
  return true;
}

void ModelRepositoryAgents_Agent::InternalSwap(ModelRepositoryAgents_Agent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  parameters_.InternalSwap(&other->parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelRepositoryAgents_Agent::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[46]);
}

// ===================================================================

class ModelRepositoryAgents::_Internal {
 public:
};

ModelRepositoryAgents::ModelRepositoryAgents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  agents_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelRepositoryAgents)
}
ModelRepositoryAgents::ModelRepositoryAgents(const ModelRepositoryAgents& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      agents_(from.agents_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:inference.ModelRepositoryAgents)
}

inline void ModelRepositoryAgents::SharedCtor() {
}

ModelRepositoryAgents::~ModelRepositoryAgents() {
  // @@protoc_insertion_point(destructor:inference.ModelRepositoryAgents)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelRepositoryAgents::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelRepositoryAgents::ArenaDtor(void* object) {
  ModelRepositoryAgents* _this = reinterpret_cast< ModelRepositoryAgents* >(object);
  (void)_this;
}
void ModelRepositoryAgents::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelRepositoryAgents::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelRepositoryAgents::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelRepositoryAgents)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  agents_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelRepositoryAgents::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .inference.ModelRepositoryAgents.Agent agents = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_agents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelRepositoryAgents::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelRepositoryAgents)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .inference.ModelRepositoryAgents.Agent agents = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_agents_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_agents(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelRepositoryAgents)
  return target;
}

size_t ModelRepositoryAgents::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelRepositoryAgents)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelRepositoryAgents.Agent agents = 1;
  total_size += 1UL * this->_internal_agents_size();
  for (const auto& msg : this->agents_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelRepositoryAgents::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelRepositoryAgents::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelRepositoryAgents::GetClassData() const { return &_class_data_; }

void ModelRepositoryAgents::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelRepositoryAgents *>(to)->MergeFrom(
      static_cast<const ModelRepositoryAgents &>(from));
}


void ModelRepositoryAgents::MergeFrom(const ModelRepositoryAgents& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelRepositoryAgents)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  agents_.MergeFrom(from.agents_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelRepositoryAgents::CopyFrom(const ModelRepositoryAgents& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelRepositoryAgents)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelRepositoryAgents::IsInitialized() const {
  return true;
}

void ModelRepositoryAgents::InternalSwap(ModelRepositoryAgents* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  agents_.InternalSwap(&other->agents_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelRepositoryAgents::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[47]);
}

// ===================================================================

class ModelResponseCache::_Internal {
 public:
};

ModelResponseCache::ModelResponseCache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelResponseCache)
}
ModelResponseCache::ModelResponseCache(const ModelResponseCache& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  enable_ = from.enable_;
  // @@protoc_insertion_point(copy_constructor:inference.ModelResponseCache)
}

inline void ModelResponseCache::SharedCtor() {
enable_ = false;
}

ModelResponseCache::~ModelResponseCache() {
  // @@protoc_insertion_point(destructor:inference.ModelResponseCache)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelResponseCache::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelResponseCache::ArenaDtor(void* object) {
  ModelResponseCache* _this = reinterpret_cast< ModelResponseCache* >(object);
  (void)_this;
}
void ModelResponseCache::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelResponseCache::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelResponseCache::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelResponseCache)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  enable_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelResponseCache::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelResponseCache::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelResponseCache)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enable = 1;
  if (this->_internal_enable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_enable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelResponseCache)
  return target;
}

size_t ModelResponseCache::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelResponseCache)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool enable = 1;
  if (this->_internal_enable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelResponseCache::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelResponseCache::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelResponseCache::GetClassData() const { return &_class_data_; }

void ModelResponseCache::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelResponseCache *>(to)->MergeFrom(
      static_cast<const ModelResponseCache &>(from));
}


void ModelResponseCache::MergeFrom(const ModelResponseCache& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelResponseCache)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_enable() != 0) {
    _internal_set_enable(from._internal_enable());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelResponseCache::CopyFrom(const ModelResponseCache& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelResponseCache)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelResponseCache::IsInitialized() const {
  return true;
}

void ModelResponseCache::InternalSwap(ModelResponseCache* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(enable_, other->enable_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelResponseCache::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[48]);
}

// ===================================================================

ModelConfig_CcModelFilenamesEntry_DoNotUse::ModelConfig_CcModelFilenamesEntry_DoNotUse() {}
ModelConfig_CcModelFilenamesEntry_DoNotUse::ModelConfig_CcModelFilenamesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelConfig_CcModelFilenamesEntry_DoNotUse::MergeFrom(const ModelConfig_CcModelFilenamesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelConfig_CcModelFilenamesEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[49]);
}

// ===================================================================

ModelConfig_MetricTagsEntry_DoNotUse::ModelConfig_MetricTagsEntry_DoNotUse() {}
ModelConfig_MetricTagsEntry_DoNotUse::ModelConfig_MetricTagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelConfig_MetricTagsEntry_DoNotUse::MergeFrom(const ModelConfig_MetricTagsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelConfig_MetricTagsEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[50]);
}

// ===================================================================

ModelConfig_ParametersEntry_DoNotUse::ModelConfig_ParametersEntry_DoNotUse() {}
ModelConfig_ParametersEntry_DoNotUse::ModelConfig_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelConfig_ParametersEntry_DoNotUse::MergeFrom(const ModelConfig_ParametersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelConfig_ParametersEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[51]);
}

// ===================================================================

class ModelConfig::_Internal {
 public:
  static const ::inference::ModelVersionPolicy& version_policy(const ModelConfig* msg);
  static const ::inference::ModelOptimizationPolicy& optimization(const ModelConfig* msg);
  static const ::inference::ModelDynamicBatching& dynamic_batching(const ModelConfig* msg);
  static const ::inference::ModelSequenceBatching& sequence_batching(const ModelConfig* msg);
  static const ::inference::ModelEnsembling& ensemble_scheduling(const ModelConfig* msg);
  static const ::inference::ModelOperations& model_operations(const ModelConfig* msg);
  static const ::inference::ModelTransactionPolicy& model_transaction_policy(const ModelConfig* msg);
  static const ::inference::ModelRepositoryAgents& model_repository_agents(const ModelConfig* msg);
  static const ::inference::ModelResponseCache& response_cache(const ModelConfig* msg);
};

const ::inference::ModelVersionPolicy&
ModelConfig::_Internal::version_policy(const ModelConfig* msg) {
  return *msg->version_policy_;
}
const ::inference::ModelOptimizationPolicy&
ModelConfig::_Internal::optimization(const ModelConfig* msg) {
  return *msg->optimization_;
}
const ::inference::ModelDynamicBatching&
ModelConfig::_Internal::dynamic_batching(const ModelConfig* msg) {
  return *msg->scheduling_choice_.dynamic_batching_;
}
const ::inference::ModelSequenceBatching&
ModelConfig::_Internal::sequence_batching(const ModelConfig* msg) {
  return *msg->scheduling_choice_.sequence_batching_;
}
const ::inference::ModelEnsembling&
ModelConfig::_Internal::ensemble_scheduling(const ModelConfig* msg) {
  return *msg->scheduling_choice_.ensemble_scheduling_;
}
const ::inference::ModelOperations&
ModelConfig::_Internal::model_operations(const ModelConfig* msg) {
  return *msg->model_operations_;
}
const ::inference::ModelTransactionPolicy&
ModelConfig::_Internal::model_transaction_policy(const ModelConfig* msg) {
  return *msg->model_transaction_policy_;
}
const ::inference::ModelRepositoryAgents&
ModelConfig::_Internal::model_repository_agents(const ModelConfig* msg) {
  return *msg->model_repository_agents_;
}
const ::inference::ModelResponseCache&
ModelConfig::_Internal::response_cache(const ModelConfig* msg) {
  return *msg->response_cache_;
}
void ModelConfig::set_allocated_dynamic_batching(::inference::ModelDynamicBatching* dynamic_batching) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scheduling_choice();
  if (dynamic_batching) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::inference::ModelDynamicBatching>::GetOwningArena(dynamic_batching);
    if (message_arena != submessage_arena) {
      dynamic_batching = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic_batching, submessage_arena);
    }
    set_has_dynamic_batching();
    scheduling_choice_.dynamic_batching_ = dynamic_batching;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.dynamic_batching)
}
void ModelConfig::set_allocated_sequence_batching(::inference::ModelSequenceBatching* sequence_batching) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scheduling_choice();
  if (sequence_batching) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::inference::ModelSequenceBatching>::GetOwningArena(sequence_batching);
    if (message_arena != submessage_arena) {
      sequence_batching = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sequence_batching, submessage_arena);
    }
    set_has_sequence_batching();
    scheduling_choice_.sequence_batching_ = sequence_batching;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.sequence_batching)
}
void ModelConfig::set_allocated_ensemble_scheduling(::inference::ModelEnsembling* ensemble_scheduling) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scheduling_choice();
  if (ensemble_scheduling) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::inference::ModelEnsembling>::GetOwningArena(ensemble_scheduling);
    if (message_arena != submessage_arena) {
      ensemble_scheduling = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ensemble_scheduling, submessage_arena);
    }
    set_has_ensemble_scheduling();
    scheduling_choice_.ensemble_scheduling_ = ensemble_scheduling;
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.ensemble_scheduling)
}
ModelConfig::ModelConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  input_(arena),
  output_(arena),
  instance_group_(arena),
  cc_model_filenames_(arena),
  metric_tags_(arena),
  parameters_(arena),
  model_warmup_(arena),
  batch_input_(arena),
  batch_output_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:inference.ModelConfig)
}
ModelConfig::ModelConfig(const ModelConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      input_(from.input_),
      output_(from.output_),
      instance_group_(from.instance_group_),
      model_warmup_(from.model_warmup_),
      batch_input_(from.batch_input_),
      batch_output_(from.batch_output_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  cc_model_filenames_.MergeFrom(from.cc_model_filenames_);
  metric_tags_.MergeFrom(from.metric_tags_);
  parameters_.MergeFrom(from.parameters_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  platform_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_platform().empty()) {
    platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_platform(), 
      GetArenaForAllocation());
  }
  default_model_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    default_model_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_model_filename().empty()) {
    default_model_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_default_model_filename(), 
      GetArenaForAllocation());
  }
  backend_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    backend_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_backend().empty()) {
    backend_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_backend(), 
      GetArenaForAllocation());
  }
  runtime_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    runtime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_runtime().empty()) {
    runtime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_runtime(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_version_policy()) {
    version_policy_ = new ::inference::ModelVersionPolicy(*from.version_policy_);
  } else {
    version_policy_ = nullptr;
  }
  if (from._internal_has_optimization()) {
    optimization_ = new ::inference::ModelOptimizationPolicy(*from.optimization_);
  } else {
    optimization_ = nullptr;
  }
  if (from._internal_has_model_operations()) {
    model_operations_ = new ::inference::ModelOperations(*from.model_operations_);
  } else {
    model_operations_ = nullptr;
  }
  if (from._internal_has_model_transaction_policy()) {
    model_transaction_policy_ = new ::inference::ModelTransactionPolicy(*from.model_transaction_policy_);
  } else {
    model_transaction_policy_ = nullptr;
  }
  if (from._internal_has_model_repository_agents()) {
    model_repository_agents_ = new ::inference::ModelRepositoryAgents(*from.model_repository_agents_);
  } else {
    model_repository_agents_ = nullptr;
  }
  if (from._internal_has_response_cache()) {
    response_cache_ = new ::inference::ModelResponseCache(*from.response_cache_);
  } else {
    response_cache_ = nullptr;
  }
  max_batch_size_ = from.max_batch_size_;
  clear_has_scheduling_choice();
  switch (from.scheduling_choice_case()) {
    case kDynamicBatching: {
      _internal_mutable_dynamic_batching()->::inference::ModelDynamicBatching::MergeFrom(from._internal_dynamic_batching());
      break;
    }
    case kSequenceBatching: {
      _internal_mutable_sequence_batching()->::inference::ModelSequenceBatching::MergeFrom(from._internal_sequence_batching());
      break;
    }
    case kEnsembleScheduling: {
      _internal_mutable_ensemble_scheduling()->::inference::ModelEnsembling::MergeFrom(from._internal_ensemble_scheduling());
      break;
    }
    case SCHEDULING_CHOICE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:inference.ModelConfig)
}

inline void ModelConfig::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
platform_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
default_model_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  default_model_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
backend_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  backend_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
runtime_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  runtime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&version_policy_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_batch_size_) -
    reinterpret_cast<char*>(&version_policy_)) + sizeof(max_batch_size_));
clear_has_scheduling_choice();
}

ModelConfig::~ModelConfig() {
  // @@protoc_insertion_point(destructor:inference.ModelConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  platform_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  default_model_filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  backend_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  runtime_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete version_policy_;
  if (this != internal_default_instance()) delete optimization_;
  if (this != internal_default_instance()) delete model_operations_;
  if (this != internal_default_instance()) delete model_transaction_policy_;
  if (this != internal_default_instance()) delete model_repository_agents_;
  if (this != internal_default_instance()) delete response_cache_;
  if (has_scheduling_choice()) {
    clear_scheduling_choice();
  }
}

void ModelConfig::ArenaDtor(void* object) {
  ModelConfig* _this = reinterpret_cast< ModelConfig* >(object);
  (void)_this;
  _this->cc_model_filenames_. ~MapField();
  _this->metric_tags_. ~MapField();
  _this->parameters_. ~MapField();
}
inline void ModelConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ModelConfig::ArenaDtor);
  }
}
void ModelConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelConfig::clear_scheduling_choice() {
// @@protoc_insertion_point(one_of_clear_start:inference.ModelConfig)
  switch (scheduling_choice_case()) {
    case kDynamicBatching: {
      if (GetArenaForAllocation() == nullptr) {
        delete scheduling_choice_.dynamic_batching_;
      }
      break;
    }
    case kSequenceBatching: {
      if (GetArenaForAllocation() == nullptr) {
        delete scheduling_choice_.sequence_batching_;
      }
      break;
    }
    case kEnsembleScheduling: {
      if (GetArenaForAllocation() == nullptr) {
        delete scheduling_choice_.ensemble_scheduling_;
      }
      break;
    }
    case SCHEDULING_CHOICE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SCHEDULING_CHOICE_NOT_SET;
}


void ModelConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:inference.ModelConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_.Clear();
  output_.Clear();
  instance_group_.Clear();
  cc_model_filenames_.Clear();
  metric_tags_.Clear();
  parameters_.Clear();
  model_warmup_.Clear();
  batch_input_.Clear();
  batch_output_.Clear();
  name_.ClearToEmpty();
  platform_.ClearToEmpty();
  default_model_filename_.ClearToEmpty();
  backend_.ClearToEmpty();
  runtime_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && version_policy_ != nullptr) {
    delete version_policy_;
  }
  version_policy_ = nullptr;
  if (GetArenaForAllocation() == nullptr && optimization_ != nullptr) {
    delete optimization_;
  }
  optimization_ = nullptr;
  if (GetArenaForAllocation() == nullptr && model_operations_ != nullptr) {
    delete model_operations_;
  }
  model_operations_ = nullptr;
  if (GetArenaForAllocation() == nullptr && model_transaction_policy_ != nullptr) {
    delete model_transaction_policy_;
  }
  model_transaction_policy_ = nullptr;
  if (GetArenaForAllocation() == nullptr && model_repository_agents_ != nullptr) {
    delete model_repository_agents_;
  }
  model_repository_agents_ = nullptr;
  if (GetArenaForAllocation() == nullptr && response_cache_ != nullptr) {
    delete response_cache_;
  }
  response_cache_ = nullptr;
  max_batch_size_ = 0;
  clear_scheduling_choice();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelConfig.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string platform = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_platform();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelConfig.platform"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelVersionPolicy version_policy = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_version_policy(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_batch_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          max_batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelInput input = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_input(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelOutput output = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_output(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelInstanceGroup instance_group = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_instance_group(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string default_model_filename = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_default_model_filename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelConfig.default_model_filename"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> cc_model_filenames = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&cc_model_filenames_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> metric_tags = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&metric_tags_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelDynamicBatching dynamic_batching = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_dynamic_batching(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOptimizationPolicy optimization = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_optimization(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelSequenceBatching sequence_batching = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_sequence_batching(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .inference.ModelParameter> parameters = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&parameters_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelEnsembling ensemble_scheduling = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_ensemble_scheduling(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.ModelWarmup model_warmup = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_model_warmup(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string backend = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_backend();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelConfig.backend"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelOperations model_operations = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_model_operations(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelTransactionPolicy model_transaction_policy = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_model_transaction_policy(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.BatchInput batch_input = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_batch_input(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .inference.BatchOutput batch_output = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_batch_output(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelRepositoryAgents model_repository_agents = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_model_repository_agents(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .inference.ModelResponseCache response_cache = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_cache(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string runtime = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          auto str = _internal_mutable_runtime();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "inference.ModelConfig.runtime"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:inference.ModelConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelConfig.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string platform = 2;
  if (!this->_internal_platform().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_platform().data(), static_cast<int>(this->_internal_platform().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelConfig.platform");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_platform(), target);
  }

  // .inference.ModelVersionPolicy version_policy = 3;
  if (this->_internal_has_version_policy()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::version_policy(this), target, stream);
  }

  // int32 max_batch_size = 4;
  if (this->_internal_max_batch_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_max_batch_size(), target);
  }

  // repeated .inference.ModelInput input = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_input_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_input(i), target, stream);
  }

  // repeated .inference.ModelOutput output = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_output_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_output(i), target, stream);
  }

  // repeated .inference.ModelInstanceGroup instance_group = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_instance_group_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_instance_group(i), target, stream);
  }

  // string default_model_filename = 8;
  if (!this->_internal_default_model_filename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_default_model_filename().data(), static_cast<int>(this->_internal_default_model_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelConfig.default_model_filename");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_default_model_filename(), target);
  }

  // map<string, string> cc_model_filenames = 9;
  if (!this->_internal_cc_model_filenames().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelConfig.CcModelFilenamesEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelConfig.CcModelFilenamesEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_cc_model_filenames().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_cc_model_filenames().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_cc_model_filenames().begin();
          it != this->_internal_cc_model_filenames().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelConfig_CcModelFilenamesEntry_DoNotUse::Funcs::InternalSerialize(9, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_cc_model_filenames().begin();
          it != this->_internal_cc_model_filenames().end(); ++it) {
        target = ModelConfig_CcModelFilenamesEntry_DoNotUse::Funcs::InternalSerialize(9, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // map<string, string> metric_tags = 10;
  if (!this->_internal_metric_tags().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelConfig.MetricTagsEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelConfig.MetricTagsEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_metric_tags().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_metric_tags().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_metric_tags().begin();
          it != this->_internal_metric_tags().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelConfig_MetricTagsEntry_DoNotUse::Funcs::InternalSerialize(10, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_metric_tags().begin();
          it != this->_internal_metric_tags().end(); ++it) {
        target = ModelConfig_MetricTagsEntry_DoNotUse::Funcs::InternalSerialize(10, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // .inference.ModelDynamicBatching dynamic_batching = 11;
  if (_internal_has_dynamic_batching()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::dynamic_batching(this), target, stream);
  }

  // .inference.ModelOptimizationPolicy optimization = 12;
  if (this->_internal_has_optimization()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::optimization(this), target, stream);
  }

  // .inference.ModelSequenceBatching sequence_batching = 13;
  if (_internal_has_sequence_batching()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::sequence_batching(this), target, stream);
  }

  // map<string, .inference.ModelParameter> parameters = 14;
  if (!this->_internal_parameters().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "inference.ModelConfig.ParametersEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_parameters().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_parameters().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >::const_iterator
          it = this->_internal_parameters().begin();
          it != this->_internal_parameters().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelConfig_ParametersEntry_DoNotUse::Funcs::InternalSerialize(14, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >::const_iterator
          it = this->_internal_parameters().begin();
          it != this->_internal_parameters().end(); ++it) {
        target = ModelConfig_ParametersEntry_DoNotUse::Funcs::InternalSerialize(14, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // .inference.ModelEnsembling ensemble_scheduling = 15;
  if (_internal_has_ensemble_scheduling()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        15, _Internal::ensemble_scheduling(this), target, stream);
  }

  // repeated .inference.ModelWarmup model_warmup = 16;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_model_warmup_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, this->_internal_model_warmup(i), target, stream);
  }

  // string backend = 17;
  if (!this->_internal_backend().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_backend().data(), static_cast<int>(this->_internal_backend().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelConfig.backend");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_backend(), target);
  }

  // .inference.ModelOperations model_operations = 18;
  if (this->_internal_has_model_operations()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        18, _Internal::model_operations(this), target, stream);
  }

  // .inference.ModelTransactionPolicy model_transaction_policy = 19;
  if (this->_internal_has_model_transaction_policy()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        19, _Internal::model_transaction_policy(this), target, stream);
  }

  // repeated .inference.BatchInput batch_input = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_batch_input_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, this->_internal_batch_input(i), target, stream);
  }

  // repeated .inference.BatchOutput batch_output = 21;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_batch_output_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, this->_internal_batch_output(i), target, stream);
  }

  // .inference.ModelRepositoryAgents model_repository_agents = 23;
  if (this->_internal_has_model_repository_agents()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        23, _Internal::model_repository_agents(this), target, stream);
  }

  // .inference.ModelResponseCache response_cache = 24;
  if (this->_internal_has_response_cache()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        24, _Internal::response_cache(this), target, stream);
  }

  // string runtime = 25;
  if (!this->_internal_runtime().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_runtime().data(), static_cast<int>(this->_internal_runtime().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "inference.ModelConfig.runtime");
    target = stream->WriteStringMaybeAliased(
        25, this->_internal_runtime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:inference.ModelConfig)
  return target;
}

size_t ModelConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:inference.ModelConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .inference.ModelInput input = 5;
  total_size += 1UL * this->_internal_input_size();
  for (const auto& msg : this->input_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .inference.ModelOutput output = 6;
  total_size += 1UL * this->_internal_output_size();
  for (const auto& msg : this->output_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .inference.ModelInstanceGroup instance_group = 7;
  total_size += 1UL * this->_internal_instance_group_size();
  for (const auto& msg : this->instance_group_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, string> cc_model_filenames = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_cc_model_filenames_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_cc_model_filenames().begin();
      it != this->_internal_cc_model_filenames().end(); ++it) {
    total_size += ModelConfig_CcModelFilenamesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, string> metric_tags = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_metric_tags_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_metric_tags().begin();
      it != this->_internal_metric_tags().end(); ++it) {
    total_size += ModelConfig_MetricTagsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .inference.ModelParameter> parameters = 14;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_parameters_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >::const_iterator
      it = this->_internal_parameters().begin();
      it != this->_internal_parameters().end(); ++it) {
    total_size += ModelConfig_ParametersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .inference.ModelWarmup model_warmup = 16;
  total_size += 2UL * this->_internal_model_warmup_size();
  for (const auto& msg : this->model_warmup_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .inference.BatchInput batch_input = 20;
  total_size += 2UL * this->_internal_batch_input_size();
  for (const auto& msg : this->batch_input_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .inference.BatchOutput batch_output = 21;
  total_size += 2UL * this->_internal_batch_output_size();
  for (const auto& msg : this->batch_output_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string platform = 2;
  if (!this->_internal_platform().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_platform());
  }

  // string default_model_filename = 8;
  if (!this->_internal_default_model_filename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_default_model_filename());
  }

  // string backend = 17;
  if (!this->_internal_backend().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_backend());
  }

  // string runtime = 25;
  if (!this->_internal_runtime().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_runtime());
  }

  // .inference.ModelVersionPolicy version_policy = 3;
  if (this->_internal_has_version_policy()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *version_policy_);
  }

  // .inference.ModelOptimizationPolicy optimization = 12;
  if (this->_internal_has_optimization()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *optimization_);
  }

  // .inference.ModelOperations model_operations = 18;
  if (this->_internal_has_model_operations()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *model_operations_);
  }

  // .inference.ModelTransactionPolicy model_transaction_policy = 19;
  if (this->_internal_has_model_transaction_policy()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *model_transaction_policy_);
  }

  // .inference.ModelRepositoryAgents model_repository_agents = 23;
  if (this->_internal_has_model_repository_agents()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *model_repository_agents_);
  }

  // .inference.ModelResponseCache response_cache = 24;
  if (this->_internal_has_response_cache()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *response_cache_);
  }

  // int32 max_batch_size = 4;
  if (this->_internal_max_batch_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_max_batch_size());
  }

  switch (scheduling_choice_case()) {
    // .inference.ModelDynamicBatching dynamic_batching = 11;
    case kDynamicBatching: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *scheduling_choice_.dynamic_batching_);
      break;
    }
    // .inference.ModelSequenceBatching sequence_batching = 13;
    case kSequenceBatching: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *scheduling_choice_.sequence_batching_);
      break;
    }
    // .inference.ModelEnsembling ensemble_scheduling = 15;
    case kEnsembleScheduling: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *scheduling_choice_.ensemble_scheduling_);
      break;
    }
    case SCHEDULING_CHOICE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelConfig::GetClassData() const { return &_class_data_; }

void ModelConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelConfig *>(to)->MergeFrom(
      static_cast<const ModelConfig &>(from));
}


void ModelConfig::MergeFrom(const ModelConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:inference.ModelConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  input_.MergeFrom(from.input_);
  output_.MergeFrom(from.output_);
  instance_group_.MergeFrom(from.instance_group_);
  cc_model_filenames_.MergeFrom(from.cc_model_filenames_);
  metric_tags_.MergeFrom(from.metric_tags_);
  parameters_.MergeFrom(from.parameters_);
  model_warmup_.MergeFrom(from.model_warmup_);
  batch_input_.MergeFrom(from.batch_input_);
  batch_output_.MergeFrom(from.batch_output_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (!from._internal_platform().empty()) {
    _internal_set_platform(from._internal_platform());
  }
  if (!from._internal_default_model_filename().empty()) {
    _internal_set_default_model_filename(from._internal_default_model_filename());
  }
  if (!from._internal_backend().empty()) {
    _internal_set_backend(from._internal_backend());
  }
  if (!from._internal_runtime().empty()) {
    _internal_set_runtime(from._internal_runtime());
  }
  if (from._internal_has_version_policy()) {
    _internal_mutable_version_policy()->::inference::ModelVersionPolicy::MergeFrom(from._internal_version_policy());
  }
  if (from._internal_has_optimization()) {
    _internal_mutable_optimization()->::inference::ModelOptimizationPolicy::MergeFrom(from._internal_optimization());
  }
  if (from._internal_has_model_operations()) {
    _internal_mutable_model_operations()->::inference::ModelOperations::MergeFrom(from._internal_model_operations());
  }
  if (from._internal_has_model_transaction_policy()) {
    _internal_mutable_model_transaction_policy()->::inference::ModelTransactionPolicy::MergeFrom(from._internal_model_transaction_policy());
  }
  if (from._internal_has_model_repository_agents()) {
    _internal_mutable_model_repository_agents()->::inference::ModelRepositoryAgents::MergeFrom(from._internal_model_repository_agents());
  }
  if (from._internal_has_response_cache()) {
    _internal_mutable_response_cache()->::inference::ModelResponseCache::MergeFrom(from._internal_response_cache());
  }
  if (from._internal_max_batch_size() != 0) {
    _internal_set_max_batch_size(from._internal_max_batch_size());
  }
  switch (from.scheduling_choice_case()) {
    case kDynamicBatching: {
      _internal_mutable_dynamic_batching()->::inference::ModelDynamicBatching::MergeFrom(from._internal_dynamic_batching());
      break;
    }
    case kSequenceBatching: {
      _internal_mutable_sequence_batching()->::inference::ModelSequenceBatching::MergeFrom(from._internal_sequence_batching());
      break;
    }
    case kEnsembleScheduling: {
      _internal_mutable_ensemble_scheduling()->::inference::ModelEnsembling::MergeFrom(from._internal_ensemble_scheduling());
      break;
    }
    case SCHEDULING_CHOICE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelConfig::CopyFrom(const ModelConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:inference.ModelConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelConfig::IsInitialized() const {
  return true;
}

void ModelConfig::InternalSwap(ModelConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  input_.InternalSwap(&other->input_);
  output_.InternalSwap(&other->output_);
  instance_group_.InternalSwap(&other->instance_group_);
  cc_model_filenames_.InternalSwap(&other->cc_model_filenames_);
  metric_tags_.InternalSwap(&other->metric_tags_);
  parameters_.InternalSwap(&other->parameters_);
  model_warmup_.InternalSwap(&other->model_warmup_);
  batch_input_.InternalSwap(&other->batch_input_);
  batch_output_.InternalSwap(&other->batch_output_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &platform_, lhs_arena,
      &other->platform_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &default_model_filename_, lhs_arena,
      &other->default_model_filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &backend_, lhs_arena,
      &other->backend_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &runtime_, lhs_arena,
      &other->runtime_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelConfig, max_batch_size_)
      + sizeof(ModelConfig::max_batch_size_)
      - PROTOBUF_FIELD_OFFSET(ModelConfig, version_policy_)>(
          reinterpret_cast<char*>(&version_policy_),
          reinterpret_cast<char*>(&other->version_policy_));
  swap(scheduling_choice_, other->scheduling_choice_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_model_5fconfig_2eproto_getter, &descriptor_table_model_5fconfig_2eproto_once,
      file_level_metadata_model_5fconfig_2eproto[52]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace inference
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::inference::ModelRateLimiter_Resource* Arena::CreateMaybeMessage< ::inference::ModelRateLimiter_Resource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelRateLimiter_Resource >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelRateLimiter* Arena::CreateMaybeMessage< ::inference::ModelRateLimiter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelRateLimiter >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelInstanceGroup_SecondaryDevice* Arena::CreateMaybeMessage< ::inference::ModelInstanceGroup_SecondaryDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelInstanceGroup_SecondaryDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelInstanceGroup* Arena::CreateMaybeMessage< ::inference::ModelInstanceGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelInstanceGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelTensorReshape* Arena::CreateMaybeMessage< ::inference::ModelTensorReshape >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelTensorReshape >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelInput* Arena::CreateMaybeMessage< ::inference::ModelInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelInput >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOutput* Arena::CreateMaybeMessage< ::inference::ModelOutput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOutput >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::BatchInput* Arena::CreateMaybeMessage< ::inference::BatchInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::BatchInput >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::BatchOutput* Arena::CreateMaybeMessage< ::inference::BatchOutput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::BatchOutput >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelVersionPolicy_Latest* Arena::CreateMaybeMessage< ::inference::ModelVersionPolicy_Latest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelVersionPolicy_Latest >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelVersionPolicy_All* Arena::CreateMaybeMessage< ::inference::ModelVersionPolicy_All >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelVersionPolicy_All >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelVersionPolicy_Specific* Arena::CreateMaybeMessage< ::inference::ModelVersionPolicy_Specific >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelVersionPolicy_Specific >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelVersionPolicy* Arena::CreateMaybeMessage< ::inference::ModelVersionPolicy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelVersionPolicy >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Graph* Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Graph >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Graph >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape* Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse* Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse* Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_Cuda* Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_Cuda >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_Cuda >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_ExecutionAccelerators* Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_ExecutionAccelerators >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_ExecutionAccelerators >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOptimizationPolicy* Arena::CreateMaybeMessage< ::inference::ModelOptimizationPolicy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOptimizationPolicy >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelQueuePolicy* Arena::CreateMaybeMessage< ::inference::ModelQueuePolicy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelQueuePolicy >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse* Arena::CreateMaybeMessage< ::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelDynamicBatching* Arena::CreateMaybeMessage< ::inference::ModelDynamicBatching >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelDynamicBatching >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching_Control* Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching_Control >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching_Control >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching_ControlInput* Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching_ControlInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching_ControlInput >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching_InitialState* Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching_InitialState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching_InitialState >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching_State* Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching_State >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching_State >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching_StrategyDirect* Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching_StrategyDirect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching_StrategyDirect >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching_StrategyOldest* Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching_StrategyOldest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching_StrategyOldest >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelSequenceBatching* Arena::CreateMaybeMessage< ::inference::ModelSequenceBatching >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelSequenceBatching >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse* Arena::CreateMaybeMessage< ::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse* Arena::CreateMaybeMessage< ::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelEnsembling_Step* Arena::CreateMaybeMessage< ::inference::ModelEnsembling_Step >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelEnsembling_Step >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelEnsembling* Arena::CreateMaybeMessage< ::inference::ModelEnsembling >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelEnsembling >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelParameter* Arena::CreateMaybeMessage< ::inference::ModelParameter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelParameter >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelWarmup_Input* Arena::CreateMaybeMessage< ::inference::ModelWarmup_Input >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelWarmup_Input >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelWarmup_InputsEntry_DoNotUse* Arena::CreateMaybeMessage< ::inference::ModelWarmup_InputsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelWarmup_InputsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelWarmup* Arena::CreateMaybeMessage< ::inference::ModelWarmup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelWarmup >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelOperations* Arena::CreateMaybeMessage< ::inference::ModelOperations >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelOperations >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelTransactionPolicy* Arena::CreateMaybeMessage< ::inference::ModelTransactionPolicy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelTransactionPolicy >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage< ::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelRepositoryAgents_Agent_ParametersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelRepositoryAgents_Agent* Arena::CreateMaybeMessage< ::inference::ModelRepositoryAgents_Agent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelRepositoryAgents_Agent >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelRepositoryAgents* Arena::CreateMaybeMessage< ::inference::ModelRepositoryAgents >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelRepositoryAgents >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelResponseCache* Arena::CreateMaybeMessage< ::inference::ModelResponseCache >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelResponseCache >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse* Arena::CreateMaybeMessage< ::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelConfig_MetricTagsEntry_DoNotUse* Arena::CreateMaybeMessage< ::inference::ModelConfig_MetricTagsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelConfig_MetricTagsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelConfig_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage< ::inference::ModelConfig_ParametersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelConfig_ParametersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::inference::ModelConfig* Arena::CreateMaybeMessage< ::inference::ModelConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::inference::ModelConfig >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
